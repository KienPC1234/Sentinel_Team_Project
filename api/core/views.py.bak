"""
ShieldCall VN â€“ Core API Views
MVP spec Section 8: All API endpoints with real business logic
"""
import re
import hashlib
import logging
import json
from urllib.parse import urlparse

from django.contrib.auth import authenticate, get_user_model
from django.db.models import Count, Sum, F, Q
from django.utils import timezone
from datetime import timedelta

from django.http import StreamingHttpResponse
from rest_framework import status, permissions, generics
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, IsAdminUser, AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.authtoken.models import Token

from api.utils.ollama_client import analyze_text_for_scam, generate_response, stream_response

from .models import (
    Domain, BankAccount, Report, ScanEvent, TrendDaily,
    EntityLink, UserAlert, ScamType, RiskLevel, ReportStatus,
)
from .serializers import (
    RegisterSerializer, LoginSerializer, UserSerializer,
    DomainSerializer, BankAccountSerializer,
    ReportCreateSerializer, ReportListSerializer, ReportModerateSerializer,
    ScanPhoneSerializer, ScanMessageSerializer, ScanDomainSerializer,
    ScanAccountSerializer, ScanImageSerializer, ScanEventListSerializer,
    TrendDailySerializer, TrendHotSerializer, UserAlertSerializer,
)

User = get_user_model()
logger = logging.getLogger(__name__)


class ChatStreamView(APIView):
    """GET /api/chat/stream â€” Stream AI response for chatbot"""
    permission_classes = [AllowAny]

    def get(self, request):
        message = request.query_params.get('message', '')
        if not message:
            return Response({'error': 'Message is required'}, status=400)

        def event_stream():
            try:
                prompt = f"Báº¡n lÃ  ShieldCall AI, má»™t chuyÃªn gia báº£o máº­t giÃºp ngÆ°á»i Viá»‡t Nam phÃ²ng chá»‘ng lá»«a Ä‘áº£o. HÃ£y tráº£ lá»i cÃ¢u há»i sau má»™t cÃ¡ch há»¯u Ã­ch, ngáº¯n gá»n vÃ  chuyÃªn nghiá»‡p: {message}"
                for chunk in stream_response(prompt):
                    yield f"data: {json.dumps({'text': chunk})}\n\n"
            except Exception as e:
                yield f"data: {json.dumps({'error': str(e)})}\n\n"

        response = StreamingHttpResponse(event_stream(), content_type='text/event-stream')
        response['Cache-Control'] = 'no-cache'
        return response


class ScanAnalyzeSSEView(APIView):
    """POST /api/scan/analyze-sse â€” Stream AI analysis for any scan result"""
    permission_classes = [AllowAny]

    def post(self, request):
        scan_type = request.data.get('scan_type', 'general')
        scan_data = request.data.get('scan_data', '')
        raw_input_val = request.data.get('raw_input', '')

        prompts = {
            'phone': f"""Báº¡n lÃ  chuyÃªn gia an ninh máº¡ng ShieldCall VN. PhÃ¢n tÃ­ch káº¿t quáº£ kiá»ƒm tra sá»‘ Ä‘iá»‡n thoáº¡i sau Ä‘Ã¢y.
Káº¿t quáº£ scan: {json.dumps(scan_data, ensure_ascii=False)}
Sá»‘ Ä‘iá»‡n thoáº¡i: {raw_input_val}
HÃ£y Ä‘Æ°a ra phÃ¢n tÃ­ch chi tiáº¿t báº±ng tiáº¿ng Viá»‡t:
1. ÄÃ¡nh giÃ¡ má»©c Ä‘á»™ nguy hiá»ƒm
2. Giáº£i thÃ­ch lÃ½ do táº¡i sao sá»‘ nÃ y an toÃ n/nguy hiá»ƒm
3. Khuyáº¿n nghá»‹ hÃ nh Ä‘á»™ng cá»¥ thá»ƒ cho ngÆ°á»i dÃ¹ng
Tráº£ lá»i ngáº¯n gá»n, rÃµ rÃ ng, dÃ¹ng markdown.""",

            'message': f"""Báº¡n lÃ  chuyÃªn gia an ninh máº¡ng ShieldCall VN. PhÃ¢n tÃ­ch tin nháº¯n/ná»™i dung sau Ä‘Ã¢y.
Káº¿t quáº£ scan: {json.dumps(scan_data, ensure_ascii=False)}
Ná»™i dung gá»‘c: {raw_input_val[:1000]}
HÃ£y Ä‘Æ°a ra phÃ¢n tÃ­ch chi tiáº¿t báº±ng tiáº¿ng Viá»‡t:
1. PhÃ¢n tÃ­ch cÃ¡c dáº¥u hiá»‡u lá»«a Ä‘áº£o (náº¿u cÃ³)
2. Giáº£i thÃ­ch chiÃªu thá»©c Ä‘Æ°á»£c sá»­ dá»¥ng
3. Khuyáº¿n nghá»‹ hÃ nh Ä‘á»™ng cá»¥ thá»ƒ
Tráº£ lá»i ngáº¯n gá»n, rÃµ rÃ ng, dÃ¹ng markdown.""",

            'domain': f"""Báº¡n lÃ  chuyÃªn gia an ninh máº¡ng ShieldCall VN. PhÃ¢n tÃ­ch káº¿t quáº£ kiá»ƒm tra website/domain.
Káº¿t quáº£ scan: {json.dumps(scan_data, ensure_ascii=False)}
URL/Domain: {raw_input_val}
HÃ£y Ä‘Æ°a ra phÃ¢n tÃ­ch chi tiáº¿t báº±ng tiáº¿ng Viá»‡t:
1. ÄÃ¡nh giÃ¡ má»©c Ä‘á»™ an toÃ n cá»§a website
2. CÃ¡c dáº¥u hiá»‡u Ä‘Ã¡ng ngá» (náº¿u cÃ³)
3. Khuyáº¿n nghá»‹ cho ngÆ°á»i dÃ¹ng
Tráº£ lá»i ngáº¯n gá»n, rÃµ rÃ ng, dÃ¹ng markdown.""",

            'account': f"""Báº¡n lÃ  chuyÃªn gia an ninh máº¡ng ShieldCall VN. PhÃ¢n tÃ­ch káº¿t quáº£ kiá»ƒm tra tÃ i khoáº£n ngÃ¢n hÃ ng.
Káº¿t quáº£ scan: {json.dumps(scan_data, ensure_ascii=False)}
ThÃ´ng tin tÃ i khoáº£n: {raw_input_val}
HÃ£y Ä‘Æ°a ra phÃ¢n tÃ­ch chi tiáº¿t báº±ng tiáº¿ng Viá»‡t:
1. ÄÃ¡nh giÃ¡ má»©c Ä‘á»™ an toÃ n
2. CÃ¡c dáº¥u hiá»‡u Ä‘Ã¡ng ngá» (náº¿u cÃ³)
3. CÃ¡ch xÃ¡c minh tÃ i khoáº£n chÃ­nh xÃ¡c
Tráº£ lá»i ngáº¯n gá»n, rÃµ rÃ ng, dÃ¹ng markdown.""",

            'image': f"""Báº¡n lÃ  chuyÃªn gia an ninh máº¡ng ShieldCall VN. PhÃ¢n tÃ­ch káº¿t quáº£ OCR vÃ  kiá»ƒm tra áº£nh/QR.
Káº¿t quáº£ scan: {json.dumps(scan_data, ensure_ascii=False)}
Ná»™i dung trÃ­ch xuáº¥t: {raw_input_val[:1000]}
HÃ£y Ä‘Æ°a ra phÃ¢n tÃ­ch chi tiáº¿t báº±ng tiáº¿ng Viá»‡t:
1. PhÃ¢n tÃ­ch ná»™i dung trÃ­ch xuáº¥t Ä‘Æ°á»£c
2. CÃ¡c dáº¥u hiá»‡u lá»«a Ä‘áº£o trong áº£nh/QR
3. Khuyáº¿n nghá»‹ hÃ nh Ä‘á»™ng
Tráº£ lá»i ngáº¯n gá»n, rÃµ rÃ ng, dÃ¹ng markdown.""",
        }

        prompt = prompts.get(scan_type, f"""Báº¡n lÃ  ShieldCall AI. HÃ£y phÃ¢n tÃ­ch káº¿t quáº£ kiá»ƒm tra sau:
{json.dumps(scan_data, ensure_ascii=False)}
Tráº£ lá»i báº±ng tiáº¿ng Viá»‡t, ngáº¯n gá»n vÃ  rÃµ rÃ ng.""")

        def event_stream():
            try:
                for chunk in stream_response(prompt):
                    yield f"data: {json.dumps({'chunk': chunk})}\n\n"
                yield f"data: {json.dumps({'done': True})}\n\n"
            except Exception as e:
                yield f"data: {json.dumps({'error': str(e), 'done': True})}\n\n"

        resp = StreamingHttpResponse(event_stream(), content_type='text/event-stream')
        resp['Cache-Control'] = 'no-cache'
        resp['X-Accel-Buffering'] = 'no'
        return resp


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUTH APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RegisterView(APIView):
    """POST /api/auth/register"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            'message': 'ÄÄƒng kÃ½ thÃ nh cÃ´ng!',
            'token': token.key,
            'user': UserSerializer(user).data,
        }, status=status.HTTP_201_CREATED)


from django.contrib.auth import authenticate, login as auth_login, get_user_model

class LoginView(APIView):
    """POST /api/auth/login"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data['email']
        password = serializer.validated_data['password']

        try:
            user_obj = User.objects.get(email=email.lower())
            user = authenticate(request, username=user_obj.username, password=password)
        except User.DoesNotExist:
            user = None

        if user is None:
            return Response({'error': 'Email hoáº·c máº­t kháº©u khÃ´ng Ä‘Ãºng.'},
                            status=status.HTTP_401_UNAUTHORIZED)

        # IMPORTANT: Create session for MPA navigation
        auth_login(request, user)
        
        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            'message': 'ÄÄƒng nháº­p thÃ nh cÃ´ng!',
            'token': token.key,
            'user': UserSerializer(user).data,
        })


class LogoutView(APIView):
    """POST /api/auth/logout â€” revoke token"""
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            request.user.auth_token.delete()
        except Exception:
            pass
        return Response({'message': 'ÄÃ£ Ä‘Äƒng xuáº¥t.'})


class MeView(APIView):
    """GET /api/me â€” current user info"""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        scan_count = ScanEvent.objects.filter(user=request.user).count()
        report_count = Report.objects.filter(reporter=request.user).count()
        alert_count = UserAlert.objects.filter(user=request.user).count()
        return Response({
            'user': UserSerializer(request.user).data,
            'stats': {
                'total_scans': scan_count,
                'total_reports': report_count,
                'saved_alerts': alert_count,
            }
        })


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SCAN APIs â€” Real business logic
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _normalize_phone(phone: str) -> str:
    """Normalize Vietnamese phone number"""
    phone = re.sub(r'[^\d+]', '', phone.strip())
    if phone.startswith('+84'):
        phone = '0' + phone[3:]
    elif phone.startswith('84') and len(phone) > 9:
        phone = '0' + phone[2:]
    return phone


def _phone_risk_score(phone_number: str) -> dict:
    """
    Phone Risk Engine (MVP spec 6.2).
    Risk = weighted sum of: reports_verified, reports_pending, recency
    """
    from api.phone_security.models import PhoneNumber
    reports = Report.objects.filter(target_type='phone', target_value=phone_number)
    approved = reports.filter(status='approved').count()
    pending = reports.filter(status='pending').count()

    # Recency boost â€” reports in last 7 days count more
    recent = reports.filter(created_at__gte=timezone.now() - timedelta(days=7)).count()

    # Check if phone exists in phone_security database
    db_risk = 0
    scam_type = 'other'
    try:
        phone_obj = PhoneNumber.objects.get(phone_number=phone_number)
        # PhoneNumber uses risk_level (SAFE/GREEN/YELLOW/RED) not numeric score
        risk_map = {'SAFE': 0, 'GREEN': 10, 'YELLOW': 40, 'RED': 70}
        db_risk = risk_map.get(getattr(phone_obj, 'risk_level', 'SAFE'), 0)
        scam_type = getattr(phone_obj, 'scam_type', 'other') or 'other'
    except Exception:
        pass

    # Weighted formula
    w_approved = 15
    w_pending = 5
    w_recent = 10
    w_db = 1

    score = min(100, (approved * w_approved) + (pending * w_pending)
                + (recent * w_recent) + (db_risk * w_db))

    if score >= 70:
        level = RiskLevel.RED
    elif score >= 40:
        level = RiskLevel.YELLOW
    elif score >= 10:
        level = RiskLevel.GREEN
    else:
        level = RiskLevel.SAFE

    # Top reasons
    reasons = []
    if approved > 0:
        reasons.append(f'{approved} bÃ¡o cÃ¡o Ä‘Ã£ xÃ¡c minh')
    if pending > 0:
        reasons.append(f'{pending} bÃ¡o cÃ¡o Ä‘ang chá» duyá»‡t')
    if recent > 0:
        reasons.append(f'{recent} bÃ¡o cÃ¡o trong 7 ngÃ y gáº§n Ä‘Ã¢y')
    if db_risk > 30:
        reasons.append('CÃ³ trong database cáº£nh bÃ¡o')
    if not reasons:
        reasons.append('KhÃ´ng tÃ¬m tháº¥y cáº£nh bÃ¡o nÃ o')

    return {
        'phone': phone_number,
        'risk_score': score,
        'risk_level': level,
        'scam_type': scam_type,
        'report_count': approved + pending,
        'reports_verified': approved,
        'last_seen': reports.order_by('-created_at').first().created_at.isoformat() if reports.exists() else None,
        'reasons': reasons[:3],
    }


class ScanPhoneView(APIView):
    """POST /api/scan/phone â€” Scan phone number risk"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ScanPhoneSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        phone = _normalize_phone(serializer.validated_data['phone'])
        if not re.match(r'^0\d{9,10}$', phone):
            return Response({'error': 'Sá»‘ Ä‘iá»‡n thoáº¡i khÃ´ng há»£p lá»‡.'},
                            status=status.HTTP_400_BAD_REQUEST)

        result = _phone_risk_score(phone)

        # Log scan event
        ScanEvent.objects.create(
            user=request.user if request.user.is_authenticated else None,
            scan_type='phone',
            raw_input=serializer.validated_data['phone'],
            normalized_input=phone,
            result_json=result,
            risk_score=result['risk_score'],
            risk_level=result['risk_level'],
        )

        return Response(result)


def _analyze_message_text(text: str) -> dict:
    """
    AI Text Analyzer (MVP spec 6.1).
    Rule-based scoring + AI analysis.
    """
    # â”€â”€ Rule-based layer â”€â”€
    rule_score = 0
    patterns_found = []
    scam_keywords = {
        r'otp|ma\s*xac\s*(nhan|thuc)|mÃ£\s*xÃ¡c': ('OTP/2FA request', 15),
        r'chuyen\s*khoan|chuyá»ƒn\s*khoáº£n|chuyá»ƒn\s*tiá»n': ('YÃªu cáº§u chuyá»ƒn khoáº£n', 15),
        r'xac\s*minh|xÃ¡c\s*minh': ('XÃ¡c minh giáº£ máº¡o', 10),
        r'phong\s*toa|phong\s*toáº£|phong\s*tá»a': ('Äe dá»a phong tá»a', 20),
        r'lenh\s*bat|lá»‡nh\s*báº¯t': ('Äe dá»a lá»‡nh báº¯t', 20),
        r'cong\s*an|cÃ´ng\s*an|bá»™\s*cÃ´ng': ('Giáº£ danh cÃ´ng an', 15),
        r'ngan\s*hang|ngÃ¢n\s*hÃ ng': ('Giáº£ danh ngÃ¢n hÃ ng', 10),
        r'khong\s*duoc\s*noi|khÃ´ng\s*Ä‘Æ°á»£c\s*nÃ³i': ('YÃªu cáº§u giá»¯ bÃ­ máº­t', 20),
        r'gap|gáº¥p|ngay\s*láº­p\s*tá»©c|khan\s*cap|kháº©n\s*cáº¥p': ('Táº¡o sá»± urgency', 10),
        r'trung\s*thuong|trÃºng\s*thÆ°á»Ÿng|trung\s*giai': ('TrÃºng thÆ°á»Ÿng giáº£', 15),
        r'https?://[^\s]+': ('Chá»©a link', 5),
        r'click|nháº¥n\s*vÃ o|báº¥m\s*vÃ o|táº£i\s*app': ('YÃªu cáº§u click/táº£i', 10),
    }

    text_lower = text.lower()
    for pattern, (label, points) in scam_keywords.items():
        if re.search(pattern, text_lower):
            rule_score += points
            patterns_found.append(label)

    rule_score = min(100, rule_score)

    # â”€â”€ AI layer (Ollama) â”€â”€
    ai_result = analyze_text_for_scam(text)
    ai_score = ai_result.get('risk_score', 0)

    # â”€â”€ Ensemble â”€â”€
    final_score = min(100, int(rule_score * 0.6 + ai_score * 0.4))

    if final_score >= 70:
        level = RiskLevel.RED
    elif final_score >= 40:
        level = RiskLevel.YELLOW
    elif final_score >= 10:
        level = RiskLevel.GREEN
    else:
        level = RiskLevel.SAFE

    # Determine scam type
    scam_type = 'other'
    if any('cÃ´ng an' in p for p in patterns_found):
        scam_type = 'police_impersonation'
    elif any('ngÃ¢n hÃ ng' in p for p in patterns_found):
        scam_type = 'bank_impersonation'
    elif any('OTP' in p for p in patterns_found):
        scam_type = 'otp_steal'
    elif any('chuyá»ƒn khoáº£n' in p for p in patterns_found):
        scam_type = 'investment_scam'
    elif any('trÃºng thÆ°á»Ÿng' in p.lower() for p in patterns_found):
        scam_type = 'other'
    elif any('link' in p.lower() for p in patterns_found):
        scam_type = 'phishing'

    # Action checklist
    actions = []
    if final_score >= 70:
        actions = ['ğŸš« KHÃ”NG chuyá»ƒn tiá»n', 'ğŸš« KHÃ”NG cung cáº¥p OTP',
                   'ğŸ“ Gá»i 113 bÃ¡o cÃ´ng an', 'ğŸ“¸ LÆ°u báº±ng chá»©ng']
    elif final_score >= 40:
        actions = ['âš ï¸ Kiá»ƒm tra láº¡i nguá»“n gá»­i', 'ğŸ” TÃ¬m kiáº¿m sá»‘/link trÃªn ShieldCall',
                   'ğŸ“ BÃ¡o cÃ¡o náº¿u nghi ngá»']
    else:
        actions = ['âœ… Tin nháº¯n cÃ³ váº» an toÃ n', 'ğŸ” Váº«n nÃªn cáº©n tháº­n vá»›i link láº¡']

    return {
        'risk_score': final_score,
        'risk_level': level,
        'scam_type': scam_type,
        'patterns_found': patterns_found,
        'ai_analysis': ai_result.get('reason', ''),
        'explanation': f'PhÃ¡t hiá»‡n {len(patterns_found)} dáº¥u hiá»‡u Ä‘Ã¡ng ngá».' if patterns_found
                       else 'KhÃ´ng phÃ¡t hiá»‡n dáº¥u hiá»‡u lá»«a Ä‘áº£o rÃµ rÃ ng.',
        'actions': actions,
        'rule_score': rule_score,
        'ai_score': ai_score,
    }


class ScanMessageView(APIView):
    """POST /api/scan/message â€” Analyze text message for scams"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ScanMessageSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        text = serializer.validated_data.get('message', '')

        # If image uploaded, do OCR with bounding boxes
        image = serializer.validated_data.get('image')
        ocr_text = ''
        ocr_result = None
        if image:
            from api.utils.media_utils import extract_ocr_with_boxes
            ocr_result = extract_ocr_with_boxes(image)
            ocr_text = ocr_result.get("text", "")
            if ocr_text:
                text = text + '\n' + ocr_text if text else ocr_text

        if not text:
            return Response({'error': 'KhÃ´ng cÃ³ ná»™i dung Ä‘á»ƒ phÃ¢n tÃ­ch.'},
                            status=status.HTTP_400_BAD_REQUEST)

        result = _analyze_message_text(text)
        if ocr_text:
            result['ocr_text'] = ocr_text
        if ocr_result:
            result['ocr_regions'] = ocr_result.get("regions", [])
            result['annotated_image'] = ocr_result.get("annotated_image_b64", "")

        # Log scan (exclude large base64 image from DB)
        log_result = {k: v for k, v in result.items() if k != 'annotated_image'}
        ScanEvent.objects.create(
            user=request.user if request.user.is_authenticated else None,
            scan_type='message',
            raw_input=text[:2000],
            normalized_input=text[:500],
            result_json=log_result,
            risk_score=result['risk_score'],
            risk_level=result['risk_level'],
        )

        return Response(result)


def _analyze_domain(url: str) -> dict:
    """
    Phishing Domain Analyzer (MVP spec 6.3).
    Feature engineering + rule-based scoring.
    """
    # Parse URL
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    parsed = urlparse(url)
    domain = parsed.netloc.lower()
    if domain.startswith('www.'):
        domain = domain[4:]

    # â”€â”€ Feature engineering â”€â”€
    score = 0
    details = []

    # Suspicious patterns
    if len(domain) > 30:
        score += 10
        details.append('Domain name dÃ i báº¥t thÆ°á»ng')
    if domain.count('.') > 3:
        score += 15
        details.append('QuÃ¡ nhiá»u subdomain')
    if domain.count('-') > 2:
        score += 10
        details.append('Nhiá»u dáº¥u gáº¡ch ngang')
    if re.search(r'\d{3,}', domain):
        score += 10
        details.append('Chá»©a nhiá»u sá»‘ liÃªn tiáº¿p')

    # Lookalike detection (Vietnamese banks + common targets)
    trusted_domains = {
        'vietcombank.com.vn': 'Vietcombank',
        'techcombank.com.vn': 'Techcombank',
        'bidv.com.vn': 'BIDV',
        'vietinbank.vn': 'VietinBank',
        'mbbank.com.vn': 'MBBank',
        'agribank.com.vn': 'Agribank',
        'tpbank.vn': 'TPBank',
        'vpbank.com.vn': 'VPBank',
        'acb.com.vn': 'ACB',
        'momo.vn': 'Momo',
        'zalopay.vn': 'ZaloPay',
        'facebook.com': 'Facebook',
        'google.com': 'Google',
    }

    similarity_warning = None
    for trusted, name in trusted_domains.items():
        # Simple Levenshtein-like check
        if trusted != domain and _is_lookalike(domain, trusted):
            score += 30
            details.append(f'Giá»‘ng domain chÃ­nh thá»©c: {name} ({trusted})')
            similarity_warning = f'CÃ³ thá»ƒ báº¡n muá»‘n vÃ o {trusted}'
            break

    # Check existing database
    try:
        db_domain = Domain.objects.get(domain_name=domain)
        score = max(score, db_domain.risk_score)
        if db_domain.report_count > 0:
            details.append(f'{db_domain.report_count} bÃ¡o cÃ¡o tá»« cá»™ng Ä‘á»“ng')
    except Domain.DoesNotExist:
        pass

    # IP-based URL
    if re.match(r'^\d+\.\d+\.\d+\.\d+$', domain):
        score += 20
        details.append('Sá»­ dá»¥ng Ä‘á»‹a chá»‰ IP thay vÃ¬ domain')

    score = min(100, score)

    if score >= 70:
        level = RiskLevel.RED
    elif score >= 40:
        level = RiskLevel.YELLOW
    elif score >= 10:
        level = RiskLevel.GREEN
    else:
        level = RiskLevel.SAFE

    result = {
        'url': url,
        'domain': domain,
        'risk_score': score,
        'risk_level': level,
        'details': details if details else ['KhÃ´ng phÃ¡t hiá»‡n dáº¥u hiá»‡u phishing'],
        'ssl': url.startswith('https'),
    }

    if similarity_warning:
        result['similarity_warning'] = similarity_warning

    # Save/update domain in DB
    Domain.objects.update_or_create(
        domain_name=domain,
        defaults={
            'risk_score': score,
            'ssl_valid': url.startswith('https'),
        }
    )

    return result


def _is_lookalike(domain: str, trusted: str) -> bool:
    """Simple lookalike detection using character substitution patterns"""
    # Remove TLD for comparison
    d1 = domain.split('.')[0]
    t1 = trusted.split('.')[0]

    if d1 == t1:
        return False  # exactly same, not lookalike

    # Common substitutions
    subs = {'0': 'o', '1': 'l', 'l': 'i', 'rn': 'm', 'vv': 'w'}
    normalized = d1
    for k, v in subs.items():
        normalized = normalized.replace(k, v)

    if normalized == t1:
        return True

    # Levenshtein distance <= 2
    if len(d1) > 3 and len(t1) > 3:
        dist = _levenshtein(d1, t1)
        if dist <= 2:
            return True

    return False


def _levenshtein(s1: str, s2: str) -> int:
    """Compute Levenshtein distance between two strings"""
    if len(s1) < len(s2):
        return _levenshtein(s2, s1)
    if len(s2) == 0:
        return len(s1)
    prev_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        curr_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = prev_row[j + 1] + 1
            deletions = curr_row[j] + 1
            substitutions = prev_row[j] + (c1 != c2)
            curr_row.append(min(insertions, deletions, substitutions))
        prev_row = curr_row
    return prev_row[-1]


class ScanDomainView(APIView):
    """POST /api/scan/domain â€” Analyze URL/domain for phishing"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ScanDomainSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        url = serializer.validated_data['url'].strip()
        result = _analyze_domain(url)

        ScanEvent.objects.create(
            user=request.user if request.user.is_authenticated else None,
            scan_type='domain',
            raw_input=url,
            normalized_input=result['domain'],
            result_json=result,
            risk_score=result['risk_score'],
            risk_level=result['risk_level'],
        )

        return Response(result)


class ScanAccountView(APIView):
    """POST /api/scan/account â€” Look up bank account risk"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ScanAccountSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        bank = serializer.validated_data['bank'].strip()
        account = serializer.validated_data['account'].strip()
        account_hash = BankAccount.hash_account(account)
        account_masked = BankAccount.mask_account(account)

        # Look up database
        score = 0
        scam_type = 'other'
        report_count = 0
        details = []

        try:
            ba = BankAccount.objects.get(bank_name=bank, account_number_hash=account_hash)
            score = ba.risk_score
            scam_type = ba.scam_type
            report_count = ba.report_count
            if report_count > 0:
                details.append(f'{report_count} bÃ¡o cÃ¡o tá»« cá»™ng Ä‘á»“ng')
        except BankAccount.DoesNotExist:
            pass

        # Check reports too
        reports_for_account = Report.objects.filter(
            target_type='account',
            target_value__icontains=account[-4:]
        ).count()
        if reports_for_account > 0:
            score = max(score, reports_for_account * 15)
            details.append(f'{reports_for_account} bÃ¡o cÃ¡o liÃªn quan')

        score = min(100, score)
        if score >= 70:
            level = RiskLevel.RED
        elif score >= 40:
            level = RiskLevel.YELLOW
        elif score >= 10:
            level = RiskLevel.GREEN
        else:
            level = RiskLevel.SAFE

        if not details:
            details.append('KhÃ´ng tÃ¬m tháº¥y cáº£nh bÃ¡o nÃ o cho tÃ i khoáº£n nÃ y')

        result = {
            'bank': bank,
            'account_masked': account_masked,
            'risk_score': score,
            'risk_level': level,
            'scam_type': scam_type,
            'report_count': report_count,
            'details': details,
        }

        # Save/update in DB
        BankAccount.objects.update_or_create(
            bank_name=bank,
            account_number_hash=account_hash,
            defaults={
                'account_number_masked': account_masked,
                'risk_score': score,
            }
        )

        ScanEvent.objects.create(
            user=request.user if request.user.is_authenticated else None,
            scan_type='account',
            raw_input=f'{bank}:{account_masked}',
            normalized_input=f'{bank}:{account_hash[:16]}',
            result_json=result,
            risk_score=score,
            risk_level=level,
        )

        return Response(result)


class ScanImageView(APIView):
    """POST /api/scan/image â€” OCR + QR decode + risk analysis with bounding boxes"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ScanImageSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        image = serializer.validated_data['image']

        # OCR extraction with bounding boxes
        from api.utils.media_utils import extract_ocr_with_boxes, extract_qr_data, analyze_image_risk
        ocr_result = extract_ocr_with_boxes(image)
        ocr_text = ocr_result.get("text", "")

        # QR code decoding
        image.seek(0)
        qr_data = extract_qr_data(image)
        image.seek(0)

        # Entity extraction from OCR text
        entities = _extract_entities_from_text(ocr_text)

        # Merge QR decoded data into entities
        if qr_data:
            for qr_item in qr_data:
                qr_entities = _extract_entities_from_text(qr_item)
                for key in ('phones', 'urls', 'accounts'):
                    if qr_entities.get(key):
                        entities.setdefault(key, [])
                        entities[key].extend(qr_entities[key])
                # If QR content is a URL not yet captured
                if qr_item.startswith(('http://', 'https://')) and qr_item not in entities.get('urls', []):
                    entities.setdefault('urls', [])
                    entities['urls'].append(qr_item)

        # Analyze risk
        risk_result = analyze_image_risk(ocr_text, image)

        result = {
            'ocr_text': ocr_text,
            'qr_data': qr_data,
            'ocr_regions': ocr_result.get("regions", []),
            'annotated_image': ocr_result.get("annotated_image_b64", ""),
            'entities': entities,
            'risk_level': risk_result.get('risk_level', 'SAFE'),
            'risk_score': 0,
            'details': risk_result.get('details', ''),
        }

        # If entities found, cross-reference
        if entities.get('phones'):
            for phone in entities['phones'][:3]:
                pr = _phone_risk_score(_normalize_phone(phone))
                result['risk_score'] = max(result['risk_score'], pr['risk_score'])
        if entities.get('urls'):
            for url in entities['urls'][:3]:
                dr = _analyze_domain(url)
                result['risk_score'] = max(result['risk_score'], dr['risk_score'])

        if result['risk_score'] >= 70:
            result['risk_level'] = RiskLevel.RED
        elif result['risk_score'] >= 40:
            result['risk_level'] = RiskLevel.YELLOW

        ScanEvent.objects.create(
            user=request.user if request.user.is_authenticated else None,
            scan_type='qr',
            raw_input=f'[image_uploaded] {ocr_text[:200]}' + (f' [QR: {", ".join(qr_data[:3])}]' if qr_data else ''),
            normalized_input=ocr_text[:500] if ocr_text else ('qr:' + ','.join(qr_data[:3]) if qr_data else 'no_text'),
            result_json={k: v for k, v in result.items() if k != 'annotated_image'},
            risk_score=result['risk_score'],
            risk_level=result['risk_level'],
        )

        return Response(result)


def _extract_entities_from_text(text: str) -> dict:
    """Extract phone numbers, URLs, bank accounts from OCR text"""
    entities = {'phones': [], 'urls': [], 'accounts': [], 'otp_codes': []}
    if not text:
        return entities

    # Phone numbers (Vietnamese format)
    phones = re.findall(r'(?:\+84|0)\d{9,10}', text)
    entities['phones'] = list(set(phones))

    # URLs
    urls = re.findall(r'https?://[^\s<>"]+', text)
    entities['urls'] = list(set(urls))

    # Bank account patterns (6-19 digits)
    accounts = re.findall(r'\b\d{6,19}\b', text)
    entities['accounts'] = list(set(accounts))[:5]

    # OTP codes (4-8 digit codes)
    otp = re.findall(r'\b\d{4,8}\b', text)
    entities['otp_codes'] = list(set(otp))[:3]

    return entities


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPORT APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ReportCreateView(APIView):
    """POST /api/report â€” Submit a scam report"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = ReportCreateSerializer(data=request.data,
                                            context={'request': request})
        serializer.is_valid(raise_exception=True)
        report = serializer.save()

        # Update report counts on related entities
        target = report.target_value
        if report.target_type == 'phone':
            from api.phone_security.models import PhoneNumber
            PhoneNumber.objects.filter(phone_number=target).update(
                reports_count=F('reports_count') + 1
            )
        elif report.target_type == 'domain':
            Domain.objects.filter(domain_name=target).update(
                report_count=F('report_count') + 1
            )

        return Response({
            'message': 'BÃ¡o cÃ¡o Ä‘Ã£ Ä‘Æ°á»£c gá»­i thÃ nh cÃ´ng! Cáº£m Æ¡n báº¡n Ä‘Ã£ giÃºp cá»™ng Ä‘á»“ng.',
            'report_id': report.pk,
            'status': report.status,
        }, status=status.HTTP_201_CREATED)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TRENDS APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TrendDailyView(APIView):
    """GET /api/trends/daily â€” Scam Radar daily trends"""
    permission_classes = [AllowAny]

    def get(self, request):
        days = int(request.query_params.get('days', 7))
        scam_type = request.query_params.get('scam_type')
        since = timezone.now().date() - timedelta(days=days)

        qs = TrendDaily.objects.filter(date__gte=since)
        if scam_type:
            qs = qs.filter(scam_type=scam_type)

        # If no precomputed trends yet, compute from reports
        if not qs.exists():
            trends = (
                Report.objects.filter(created_at__date__gte=since)
                .values('created_at__date', 'scam_type')
                .annotate(count=Count('id'))
                .order_by('created_at__date')
            )
            return Response({
                'trends': [
                    {'date': str(t['created_at__date']),
                     'scam_type': t['scam_type'],
                     'count': t['count']}
                    for t in trends
                ],
                'source': 'computed',
            })

        return Response({
            'trends': TrendDailySerializer(qs, many=True).data,
            'source': 'precomputed',
        })


class TrendHotView(APIView):
    """GET /api/trends/hot â€” Hot/rising scam targets"""
    permission_classes = [AllowAny]

    def get(self, request):
        since = timezone.now() - timedelta(days=7)
        hot_phones = (
            Report.objects.filter(
                target_type='phone',
                created_at__gte=since,
            )
            .values('target_value', 'scam_type')
            .annotate(report_count=Count('id'))
            .order_by('-report_count')[:10]
        )

        hot_domains = (
            Report.objects.filter(
                target_type='domain',
                created_at__gte=since,
            )
            .values('target_value', 'scam_type')
            .annotate(report_count=Count('id'))
            .order_by('-report_count')[:10]
        )

        results = []
        for item in hot_phones:
            results.append({
                'target_type': 'phone',
                'target_value': item['target_value'],
                'report_count': item['report_count'],
                'risk_change': item['report_count'] * 10,
                'scam_type': item['scam_type'],
            })
        for item in hot_domains:
            results.append({
                'target_type': 'domain',
                'target_value': item['target_value'],
                'report_count': item['report_count'],
                'risk_change': item['report_count'] * 10,
                'scam_type': item['scam_type'],
            })

        results.sort(key=lambda x: x['report_count'], reverse=True)
        return Response({'hot': results[:15]})


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USER APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UserScansView(generics.ListAPIView):
    """GET /api/user/scans â€” User scan history"""
    serializer_class = ScanEventListSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        qs = ScanEvent.objects.filter(user=self.request.user)
        scan_type = self.request.query_params.get('type')
        if scan_type:
            qs = qs.filter(scan_type=scan_type)
        return qs[:50]


class UserReportsView(generics.ListAPIView):
    """GET /api/user/reports â€” User report history"""
    serializer_class = ReportListSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return Report.objects.filter(reporter=self.request.user)[:50]


class UserAlertsView(APIView):
    """GET/POST /api/user/alerts â€” User saved alerts"""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        alerts = UserAlert.objects.filter(user=request.user)
        return Response(UserAlertSerializer(alerts, many=True).data)

    def post(self, request):
        serializer = UserAlertSerializer(data=request.data,
                                         context={'request': request})
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def delete(self, request):
        alert_id = request.data.get('id')
        if alert_id:
            UserAlert.objects.filter(user=request.user, id=alert_id).delete()
        return Response({'message': 'ÄÃ£ xÃ³a cáº£nh bÃ¡o.'})


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ADMIN APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AdminReportsView(generics.ListAPIView):
    """GET /api/admin/reports â€” Moderation queue"""
    serializer_class = ReportListSerializer
    permission_classes = [IsAdminUser]

    def get_queryset(self):
        qs = Report.objects.all()
        st = self.request.query_params.get('status', 'pending')
        if st:
            qs = qs.filter(status=st)
        return qs[:100]


class AdminReportActionView(APIView):
    """POST /api/admin/reports/{id}/action â€” Approve or reject a report"""
    permission_classes = [IsAdminUser]

    def post(self, request, report_id):
        serializer = ReportModerateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        try:
            report = Report.objects.get(pk=report_id)
        except Report.DoesNotExist:
            return Response({'error': 'Report khÃ´ng tá»“n táº¡i.'},
                            status=status.HTTP_404_NOT_FOUND)

        action = serializer.validated_data['action']
        report.status = 'approved' if action == 'approve' else 'rejected'
        report.moderator = request.user
        report.moderation_note = serializer.validated_data.get('note', '')
        report.save()

        # If approved, update entity risk scores
        if action == 'approve':
            if report.target_type == 'phone':
                from .tasks import recompute_phone_risk
                recompute_phone_risk.delay(report.target_value)
            elif report.target_type == 'domain':
                Domain.objects.filter(domain_name=report.target_value).update(
                    risk_score=F('risk_score') + 15,
                    report_count=F('report_count') + 1,
                )

        return Response({
            'message': f'Report #{report_id} Ä‘Ã£ Ä‘Æ°á»£c {action}.',
            'status': report.status,
        })


class AdminStatsView(APIView):
    """GET /api/admin/stats â€” System overview stats"""
    permission_classes = [IsAdminUser]

    def get(self, request):
        today = timezone.now().date()
        week_ago = today - timedelta(days=7)

        return Response({
            'total_users': User.objects.count(),
            'total_scans': ScanEvent.objects.count(),
            'total_reports': Report.objects.count(),
            'pending_reports': Report.objects.filter(status='pending').count(),
            'scans_today': ScanEvent.objects.filter(created_at__date=today).count(),
            'scans_week': ScanEvent.objects.filter(created_at__date__gte=week_ago).count(),
            'reports_week': Report.objects.filter(created_at__date__gte=week_ago).count(),
            'domains_tracked': Domain.objects.count(),
            'accounts_tracked': BankAccount.objects.count(),
        })


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FORUM APIs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ForumPostListCreateView(APIView):
    """GET /api/forum/posts/ â€” list, POST â€” create"""

    def get_permissions(self):
        if self.request.method == 'POST':
            return [IsAuthenticated()]
        return [AllowAny()]

    def get(self, request):
        from api.core.models import ForumPost
        posts = ForumPost.objects.select_related('author').order_by('-is_pinned', '-created_at')[:50]
        data = [{
            'id': p.id,
            'title': p.title,
            'content': p.content[:300],
            'category': p.category,
            'author_name': p.author.first_name or p.author.username,
            'likes_count': p.likes_count,
            'comments_count': p.comments_count,
            'is_pinned': p.is_pinned,
            'created_at': p.created_at.isoformat(),
            'user_liked': p.likes.filter(user=request.user).exists() if request.user.is_authenticated else False,
        } for p in posts]
        return Response(data)

    def post(self, request):
        from api.core.models import ForumPost
        title = request.data.get('title', '').strip()
        content = request.data.get('content', '').strip()
        category = request.data.get('category', 'discussion')

        if not title or not content:
            return Response({'error': 'TiÃªu Ä‘á» vÃ  ná»™i dung khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng'}, status=400)

        post = ForumPost.objects.create(
            author=request.user,
            title=title,
            content=content,
            category=category,
        )
        return Response({
            'id': post.id,
            'title': post.title,
            'content': post.content[:300],
            'category': post.category,
            'author_name': request.user.first_name or request.user.username,
            'likes_count': 0,
            'comments_count': 0,
            'is_pinned': False,
            'created_at': post.created_at.isoformat(),
            'user_liked': False,
        }, status=201)


class ForumPostCommentView(APIView):
    """POST /api/forum/posts/<id>/comment/"""
    permission_classes = [IsAuthenticated]

    def post(self, request, post_id):
        from api.core.models import ForumPost, ForumComment
        try:
            post = ForumPost.objects.get(id=post_id)
        except ForumPost.DoesNotExist:
            return Response({'error': 'BÃ i viáº¿t khÃ´ng tá»“n táº¡i'}, status=404)

        content = request.data.get('content', '').strip()
        if not content:
            return Response({'error': 'Ná»™i dung bÃ¬nh luáº­n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng'}, status=400)

        comment = ForumComment.objects.create(
            post=post,
            author=request.user,
            content=content,
        )
        post.comments_count = F('comments_count') + 1
        post.save(update_fields=['comments_count'])

        return Response({
            'id': comment.id,
            'author_name': request.user.first_name or request.user.username,
            'content': comment.content,
            'created_at': comment.created_at.isoformat(),
        }, status=201)


class ForumPostLikeView(APIView):
    """POST /api/forum/posts/<id>/like/ â€” toggle like"""
    permission_classes = [IsAuthenticated]

    def post(self, request, post_id):
        from api.core.models import ForumPost, ForumLike
        try:
            post = ForumPost.objects.get(id=post_id)
        except ForumPost.DoesNotExist:
            return Response({'error': 'BÃ i viáº¿t khÃ´ng tá»“n táº¡i'}, status=404)

        like, created = ForumLike.objects.get_or_create(user=request.user, post=post)
        if not created:
            like.delete()
            post.likes_count = F('likes_count') - 1
            post.save(update_fields=['likes_count'])
            post.refresh_from_db()
            return Response({'liked': False, 'likes_count': post.likes_count})
        else:
            post.likes_count = F('likes_count') + 1
            post.save(update_fields=['likes_count'])
            post.refresh_from_db()
            return Response({'liked': True, 'likes_count': post.likes_count})
