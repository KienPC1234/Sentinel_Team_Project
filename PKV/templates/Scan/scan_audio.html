{% extends "base.html" %}
{% load static %}

{% block title %}Quét Âm Thanh - ShieldCall VN{% endblock %}

{% block content %}
<div class="max-w-7xl mx-auto px-4 lg:grid lg:grid-cols-[1fr_340px] lg:gap-8 lg:items-start">
<div class="space-y-10" x-data="audioScanHandler()">

    <!-- Page Header -->
    <div class="text-center space-y-4" data-aos="fade-up">
        <div class="relative inline-block" data-aos="zoom-in" data-aos-delay="100">
            <div class="absolute inset-0 bg-violet-500 blur-3xl opacity-20 rounded-full scale-150"></div>
            <div class="relative inline-flex items-center justify-center w-20 h-20 rounded-[2rem] bg-violet-500/10 text-violet-400 border border-violet-500/20 shadow-lg shadow-violet-500/10">
                <i class="bi bi-soundwave text-4xl"></i>
            </div>
        </div>
        <h1 class="text-4xl font-black text-white tracking-tight leading-none" data-aos="fade-up" data-aos-delay="200">
            Quét <span class="glow-text text-violet-400">Âm Thanh</span>
        </h1>
        <p class="text-white/40 max-w-lg mx-auto text-sm leading-relaxed" data-aos="fade-up" data-aos-delay="300">
            Tải lên cuộc gọi ghi âm hoặc ghi âm trực tiếp — AI sẽ chuyển đổi giọng nói thành văn bản và phân tích dấu hiệu lừa đảo trong hội thoại.
        </p>
    </div>

    <!-- ═══ UPLOAD / RECORD CARD ═══ -->
    <div x-show="!result" class="liquid-card p-0 relative group overflow-hidden" data-aos="fade-up" data-aos-delay="400">
        <div class="absolute inset-0 bg-gradient-to-br from-violet-500/5 to-fuchsia-500/5 opacity-0 group-hover:opacity-100 transition-opacity"></div>

        <!-- Tab Selector -->
        <div class="relative z-10 flex border-b border-white/5">
            <button @click="mode = 'upload'" class="flex-1 py-5 text-center text-[11px] font-black uppercase tracking-[0.2em] transition-all border-b-2 relative"
                    :class="mode === 'upload' ? 'text-violet-400 border-violet-500 bg-violet-500/5' : 'text-white/30 border-transparent hover:text-white/50'">
                <i class="bi bi-cloud-arrow-up-fill mr-2 text-lg align-middle"></i>Tải File
            </button>
            <button @click="mode = 'record'" class="flex-1 py-5 text-center text-[11px] font-black uppercase tracking-[0.2em] transition-all border-b-2 relative"
                    :class="mode === 'record' ? 'text-violet-400 border-violet-500 bg-violet-500/5' : 'text-white/30 border-transparent hover:text-white/50'">
                <i class="bi bi-mic-fill mr-2 text-lg align-middle"></i>Ghi Âm
            </button>
        </div>

        <div class="relative z-10 p-6 sm:p-10">
            <!-- ─── UPLOAD MODE ─── -->
            <div x-show="mode === 'upload'" x-transition>
                <template x-if="!audioFile">
                    <div class="flex flex-col items-center justify-center py-16 border-2 border-dashed border-white/10 rounded-3xl hover:border-violet-500/30 transition-all cursor-pointer group/drop"
                         @click="$refs.audioInput.click()"
                         @dragover.prevent="dragging = true"
                         @dragleave.prevent="dragging = false"
                         @drop.prevent="handleDrop($event)"
                         :class="dragging ? 'bg-violet-500/10 border-violet-500/50 scale-[0.99]' : ''">
                        <input type="file" x-ref="audioInput" accept=".mp3,.m4a,.wav,.ogg,.webm,.flac,.aac,audio/*" class="hidden"
                               @change="handleFileSelect($event)">
                        <div class="relative mb-6">
                            <div class="absolute inset-0 bg-violet-500/20 blur-2xl rounded-full scale-150 opacity-0 group-hover/drop:opacity-100 transition-opacity"></div>
                            <div class="relative w-20 h-20 rounded-[1.5rem] bg-white/[0.03] border border-white/10 flex items-center justify-center group-hover/drop:border-violet-500/30 group-hover/drop:scale-110 transition-all duration-300">
                                <i class="bi bi-file-earmark-music text-4xl text-white/15 group-hover/drop:text-violet-400/60 transition-colors"></i>
                            </div>
                        </div>
                        <p class="text-white font-black text-lg mb-2">Click hoặc kéo thả file âm thanh</p>
                        <p class="text-white/30 text-xs font-bold">MP3 · WAV · M4A · OGG · WebM · FLAC · AAC <span class="text-white/15 ml-1">Tối đa 50MB</span></p>
                    </div>
                </template>

                <template x-if="audioFile">
                    <div class="space-y-5">
                        <div class="bg-white/[0.02] rounded-2xl p-5 border border-white/10 flex items-center gap-5">
                            <div class="relative">
                                <div class="absolute inset-0 bg-violet-500 blur-xl opacity-20"></div>
                                <div class="relative w-14 h-14 rounded-2xl bg-violet-500/10 flex items-center justify-center text-violet-400 text-2xl border border-violet-500/20">
                                    <i class="bi bi-file-earmark-music-fill"></i>
                                </div>
                            </div>
                            <div class="flex-1 min-w-0">
                                <h4 class="text-white font-black truncate text-sm" x-text="audioFile.name"></h4>
                                <p class="text-white/30 text-[11px] font-bold mt-0.5" x-text="formatBytes(audioFile.size)"></p>
                            </div>
                            <button @click="removeFile()" x-show="!loading" class="w-10 h-10 rounded-xl bg-white/5 hover:bg-red-500/10 text-white/20 hover:text-red-400 flex items-center justify-center transition-all">
                                <i class="bi bi-trash3 text-sm"></i>
                            </button>
                        </div>
                        <audio x-ref="audioPreview" controls class="w-full rounded-xl [&::-webkit-media-controls-panel]{background:rgba(255,255,255,0.03)}"></audio>
                    </div>
                </template>
            </div>

            <!-- ─── RECORD MODE ─── -->
            <div x-show="mode === 'record'" x-transition class="space-y-6">

                <!-- Microphone Selector -->
                <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-3" x-show="!isRecording">
                    <div class="flex-1 relative">
                        <div class="absolute left-4 top-1/2 -translate-y-1/2 text-white/20 pointer-events-none">
                            <i class="bi bi-mic"></i>
                        </div>
                        <select x-model="selectedDeviceId" @change="testSelectedMic()"
                                class="w-full bg-white/[0.03] border border-white/10 text-white/80 text-sm font-bold rounded-xl pl-10 pr-4 py-3 appearance-none focus:border-violet-500/50 focus:ring-1 focus:ring-violet-500/20 transition-all cursor-pointer">
                            <option value="" class="bg-slate-900">Micro mặc định</option>
                            <template x-for="d in audioDevices" :key="d.deviceId">
                                <option :value="d.deviceId" x-text="d.label || ('Microphone ' + (audioDevices.indexOf(d)+1))" class="bg-slate-900"></option>
                            </template>
                        </select>
                        <div class="absolute right-4 top-1/2 -translate-y-1/2 text-white/20 pointer-events-none">
                            <i class="bi bi-chevron-down text-xs"></i>
                        </div>
                    </div>
                    <button @click="refreshDevices()" class="px-4 py-3 rounded-xl bg-white/5 border border-white/10 text-white/40 hover:text-violet-400 hover:border-violet-500/30 transition-all text-xs font-black uppercase tracking-widest"
                            title="Làm mới danh sách micro">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                </div>

                <!-- Mic Level Indicator (before recording) -->
                <div x-show="micTesting && !isRecording" class="flex items-center gap-3 px-4 py-3 rounded-xl bg-white/[0.02] border border-white/5">
                    <span class="text-[10px] font-black text-white/30 uppercase tracking-widest shrink-0">Mức thu</span>
                    <div class="flex-1 h-2 bg-white/5 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-100"
                             :style="'width:' + micLevel + '%'"
                             :class="micLevel > 60 ? 'bg-green-500' : micLevel > 20 ? 'bg-yellow-400' : 'bg-white/20'"></div>
                    </div>
                    <span class="text-[10px] font-mono text-white/20" x-text="Math.round(micLevel) + '%'"></span>
                </div>

                <!-- Recording Area -->
                <div class="flex flex-col items-center py-8">
                    <!-- Big Record Button -->
                    <div class="relative mb-6">
                        <!-- Rotating ring when recording -->
                        <div x-show="isRecording" class="absolute -inset-4">
                            <svg class="w-full h-full animate-spin-slow" viewBox="0 0 160 160">
                                <circle cx="80" cy="80" r="76" fill="none" stroke="rgba(239,68,68,0.15)" stroke-width="2" stroke-dasharray="8 12"/>
                            </svg>
                        </div>
                        <!-- Pulse rings -->
                        <div x-show="isRecording" class="absolute -inset-6 rounded-full bg-red-500/10 animate-ping"></div>
                        <div x-show="isRecording" class="absolute -inset-3 rounded-full bg-red-500/5 animate-pulse"></div>

                        <button @click="isRecording ? stopRecording() : startRecording()"
                                class="relative w-28 h-28 rounded-full flex items-center justify-center text-4xl transition-all duration-500 z-10 shadow-2xl"
                                :class="isRecording
                                    ? 'bg-gradient-to-br from-red-500 to-red-600 text-white shadow-red-500/40 scale-110 hover:from-red-400 hover:to-red-500'
                                    : 'bg-white/[0.03] text-white/30 border-2 border-white/10 hover:border-violet-500/50 hover:text-violet-400 hover:shadow-violet-500/20 hover:scale-105'">
                            <i :class="isRecording ? 'bi bi-stop-fill' : 'bi bi-mic-fill'" class="transition-all"></i>
                        </button>
                    </div>

                    <!-- Status Text -->
                    <div class="text-center space-y-2">
                        <p x-show="!isRecording && !recordedBlob" class="text-white/40 text-sm font-bold">Nhấn để bắt đầu ghi âm</p>
                        <div x-show="isRecording" class="space-y-3">
                            <p class="text-red-400 text-sm font-black animate-pulse flex items-center justify-center gap-2">
                                <span class="w-2 h-2 rounded-full bg-red-500 shadow-lg shadow-red-500/50"></span>
                                Đang ghi âm — <span x-text="formatTime(recordingDuration)"></span>
                                <span class="text-white/15 text-xs" x-text="'/ ' + formatTime(maxRecordingDuration)"></span>
                            </p>
                            <!-- Live Waveform -->
                            <canvas x-ref="waveCanvas" width="320" height="64" class="rounded-2xl mx-auto opacity-90"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Recorded File Preview -->
                <template x-if="recordedBlob && !isRecording">
                    <div class="space-y-4 animate-fadein">
                        <div class="bg-white/[0.02] rounded-2xl p-5 border border-green-500/10 flex items-center gap-5">
                            <div class="relative">
                                <div class="absolute inset-0 bg-green-500 blur-xl opacity-20"></div>
                                <div class="relative w-14 h-14 rounded-2xl bg-green-500/10 flex items-center justify-center text-green-400 text-2xl border border-green-500/20">
                                    <i class="bi bi-check-circle-fill"></i>
                                </div>
                            </div>
                            <div class="flex-1 min-w-0">
                                <h4 class="text-white font-black text-sm">Bản ghi âm hoàn tất</h4>
                                <p class="text-white/30 text-[11px] font-bold mt-0.5" x-text="formatTime(recordingDuration) + ' • ' + formatBytes(recordedBlob.size)"></p>
                            </div>
                            <button @click="discardRecording()" x-show="!loading" class="w-10 h-10 rounded-xl bg-white/5 hover:bg-red-500/10 text-white/20 hover:text-red-400 flex items-center justify-center transition-all">
                                <i class="bi bi-trash3 text-sm"></i>
                            </button>
                        </div>
                        <audio x-ref="recordedPreview" controls class="w-full rounded-xl"></audio>
                    </div>
                </template>
            </div>

            <!-- ─── SCAN BUTTON ─── -->
            <div class="mt-8 flex flex-col items-center gap-6" x-show="hasAudio && !loading && !scanning">
                <div class="cf-turnstile" data-sitekey="{{ TURNSTILE_SITEKEY }}" :data-theme="document.documentElement.getAttribute('data-theme') || 'dark'" data-size="flexible"></div>
                <button @click="startScan()" class="relative group/scan overflow-hidden rounded-2xl w-full sm:w-auto">
                    <div class="absolute inset-0 bg-gradient-to-r from-violet-600 to-fuchsia-600 opacity-0 group-hover/scan:opacity-100 transition-opacity"></div>
                    <div class="relative bg-violet-500 hover:bg-violet-400 text-white px-14 py-4 rounded-2xl font-black text-[11px] uppercase tracking-[0.3em] shadow-xl shadow-violet-500/25 flex items-center justify-center gap-3 transition-all group-hover/scan:scale-[1.02]">
                        <i class="bi bi-shield-shaded text-lg"></i> Phân tích âm thanh
                    </div>
                </button>
            </div>
        </div>
    </div>

    <!-- ═══ PROGRESS CONSOLE ═══ -->
    <template x-if="(loading || scanning) && progress.length > 0">
        <div class="liquid-card p-6 border-violet-500/20 bg-violet-500/[0.02] animate-fadein overflow-hidden">
            <div class="mb-4 flex items-center justify-between gap-3">
                <h4 class="text-[10px] font-black text-violet-400 uppercase tracking-[0.2em] flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-violet-500 animate-pulse"></span>
                    Nhật ký phân tích
                </h4>
                <div class="flex items-center gap-3">
                    <span class="text-[10px] text-white/20 font-mono" x-text="progress.length + ' bước'"></span>
                    <div class="text-[10px] font-black uppercase tracking-wider px-2.5 py-1 rounded-lg border"
                         :class="wsState==='connected' ? 'text-green-400 border-green-500/20 bg-green-500/5' : (wsState==='reconnecting' || wsState==='connecting') ? 'text-yellow-400 border-yellow-500/20 bg-yellow-500/5' : 'text-red-400 border-red-500/20 bg-red-500/5'"
                         x-text="wsState==='connected' ? 'LIVE' : (wsState==='reconnecting' ? 'RETRY' : (wsState==='connecting' ? '...' : 'OFFLINE'))"></div>
                </div>
            </div>
            <div class="w-full h-1 bg-white/5 rounded-full overflow-hidden mb-5">
                <div class="h-full bg-gradient-to-r from-violet-500/50 to-fuchsia-500/50 transition-all duration-700 rounded-full"
                     :style="'width:' + Math.min(95, progress.length * 20) + '%'"></div>
            </div>
            <div class="space-y-3 font-mono text-[11px] max-h-[300px] overflow-y-auto custom-scrollbar">
                <template x-for="(item, index) in progress" :key="index">
                    <div class="flex items-start gap-3 animate-fadein">
                        <span class="flex-shrink-0 mt-0.5"
                              :class="item.step === 'completed' ? 'text-green-500' :
                                      item.step === 'error' ? 'text-red-500' :
                                      item.step === 'transcribing' ? 'text-blue-400' :
                                      item.step === 'transcribed' ? 'text-emerald-400' :
                                      item.step === 'analyzing' || item.step === 'analyzed' ? 'text-orange-400' :
                                      'text-violet-500/50'">
                            <i :class="item.step === 'completed' ? 'bi bi-check-circle-fill' :
                                       item.step === 'error' ? 'bi bi-x-circle-fill' :
                                       item.step === 'transcribing' ? 'bi bi-soundwave' :
                                       item.step === 'transcribed' ? 'bi bi-chat-left-text-fill' :
                                       item.step === 'analyzing' || item.step === 'analyzed' ? 'bi bi-cpu-fill' :
                                       (index === progress.length - 1 ? 'bi bi-arrow-right' : 'bi bi-dot')"></i>
                        </span>
                        <span class="text-white/80 flex-1" x-text="item.message"></span>
                        <i x-show="index === progress.length - 1 && item.step !== 'completed'" class="bi bi-three-dots animate-pulse text-violet-400 flex-shrink-0"></i>
                    </div>
                </template>
            </div>

            <!-- Live transcript preview -->
            <template x-if="liveTranscript">
                <div class="mt-5 p-4 rounded-2xl bg-white/[0.02] border border-white/5">
                    <div class="text-[9px] font-black text-white/20 uppercase tracking-[0.2em] mb-2 flex items-center gap-2">
                        <i class="bi bi-chat-left-text text-violet-400/40"></i> Bản ghi nhận dạng
                    </div>
                    <p class="text-white/60 text-sm leading-relaxed italic" x-text="liveTranscript"></p>
                </div>
            </template>
        </div>
    </template>

    <!-- ═══ RESULT DISPLAY ═══ -->
    <template x-if="result">
        <div class="space-y-8 animate-fadein">
            <div class="liquid-card overflow-hidden p-0">
                <!-- Status Header -->
                <div class="p-10 text-center relative overflow-hidden">
                    <div class="absolute inset-0 opacity-10 -z-10 blur-[100px]"
                         :class="result.risk_level==='RED' ? 'bg-red-500' : result.risk_level==='YELLOW' ? 'bg-yellow-500' : 'bg-green-500'"></div>
                    <div class="absolute inset-x-0 bottom-0 h-px bg-gradient-to-r from-transparent via-white/10 to-transparent"></div>

                    <!-- Risk Badge -->
                    <div class="inline-flex items-center gap-2.5 mb-6 px-4 py-2 rounded-full border"
                         :class="result.risk_level==='RED' ? 'bg-red-500/10 border-red-500/20 text-red-400' : result.risk_level==='YELLOW' ? 'bg-yellow-500/10 border-yellow-500/20 text-yellow-400' : 'bg-green-500/10 border-green-500/20 text-green-400'">
                        <span class="w-2 h-2 rounded-full animate-pulse"
                              :class="result.risk_level==='RED' ? 'bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.5)]' : result.risk_level==='YELLOW' ? 'bg-yellow-400 shadow-[0_0_8px_rgba(250,204,21,0.5)]' : 'bg-green-400 shadow-[0_0_8px_rgba(74,222,128,0.5)]'"></span>
                        <span class="text-xs font-black uppercase tracking-[0.2em]"
                              x-text="result.risk_level === 'RED' ? 'Nguy hiểm cao' : result.risk_level === 'YELLOW' ? 'Cần cảnh giác' : 'An toàn'"></span>
                    </div>

                    <!-- Score Ring -->
                    <div class="relative inline-block mb-5">
                        <svg class="w-40 h-40 transform -rotate-90" viewBox="0 0 160 160">
                            <circle cx="80" cy="80" r="70" stroke="currentColor" stroke-width="6" fill="transparent" class="text-white/5" />
                            <circle cx="80" cy="80" r="70" stroke="currentColor" stroke-width="6" fill="transparent"
                                    stroke-linecap="round"
                                    :stroke-dasharray="440" :stroke-dashoffset="440 * (1 - (result.risk_score || 0)/100)"
                                    :class="result.risk_level==='RED' ? 'text-red-500' : result.risk_level==='YELLOW' ? 'text-yellow-400' : 'text-green-400'"
                                    class="transition-all duration-1000 ease-out" />
                        </svg>
                        <div class="absolute inset-0 flex flex-col items-center justify-center">
                            <span class="text-5xl font-black text-white" x-text="result.risk_score || 0"></span>
                            <span class="text-[9px] uppercase font-black text-white/20 tracking-[0.2em] mt-1">Điểm rủi ro</span>
                        </div>
                    </div>

                    <!-- Audio Meta -->
                    <div class="flex justify-center gap-6 text-[11px] text-white/30 font-bold">
                        <span x-show="result.language"><i class="bi bi-translate mr-1.5"></i><span x-text="result.language"></span></span>
                        <span x-show="result.duration"><i class="bi bi-clock mr-1.5"></i><span x-text="result.duration ? result.duration.toFixed(1) + 's' : ''"></span></span>
                        <span x-show="result.segments"><i class="bi bi-list-ol mr-1.5"></i><span x-text="(result.segments?.length || 0) + ' đoạn'"></span></span>
                    </div>
                </div>

                <div class="p-8 space-y-10">
                    <!-- Transcript (Segments) -->
                    <div class="space-y-4">
                        <h4 class="text-[10px] font-black text-violet-400 uppercase tracking-[0.2em] flex items-center gap-2">
                            <i class="bi bi-chat-left-text"></i> Nội dung nhận diện
                        </h4>
                        <template x-if="result.segments && result.segments.length > 0">
                            <div class="space-y-2 max-h-[400px] overflow-y-auto custom-scrollbar">
                                <template x-for="(seg, idx) in result.segments" :key="idx">
                                    <div class="flex gap-3 p-3 rounded-xl bg-white/[0.02] border border-white/5 hover:bg-white/[0.04] transition-colors group/seg">
                                        <span class="text-[10px] font-mono text-violet-400/40 whitespace-nowrap pt-0.5 group-hover/seg:text-violet-400/70 transition-colors"
                                              x-text="formatTimestamp(seg.start) + ' →'"></span>
                                        <span class="text-white/70 text-sm leading-relaxed" x-text="seg.text"></span>
                                    </div>
                                </template>
                            </div>
                        </template>
                        <template x-if="!result.segments || result.segments.length === 0">
                            <div class="p-5 rounded-2xl bg-white/[0.02] border border-white/5">
                                <p class="text-white/60 text-sm leading-relaxed" x-text="result.transcript || 'Không nhận diện được nội dung.'"></p>
                            </div>
                        </template>
                    </div>

                    <!-- Full Transcript -->
                    <template x-if="result.transcript">
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="text-[10px] font-black text-white/30 uppercase tracking-[0.2em] flex items-center gap-2">
                                    <i class="bi bi-file-text"></i> Văn bản đầy đủ
                                </h4>
                                <button @click="navigator.clipboard.writeText(result.transcript); showToast('Đã sao chép!','success')"
                                        class="px-3 py-1.5 rounded-lg bg-white/5 hover:bg-violet-500/10 text-white/30 hover:text-violet-400 border border-white/5 hover:border-violet-500/20 text-[10px] font-black uppercase tracking-widest transition-all">
                                    <i class="bi bi-copy mr-1"></i> Sao chép
                                </button>
                            </div>
                            <div class="p-5 rounded-2xl bg-black/30 border border-white/5 max-h-[200px] overflow-y-auto custom-scrollbar">
                                <p class="text-white/40 text-sm leading-relaxed font-mono whitespace-pre-wrap" x-text="result.transcript"></p>
                            </div>
                        </div>
                    </template>

                    <!-- AI Analysis -->
                    <div class="space-y-4">
                        <h4 class="text-[10px] font-black text-violet-400 uppercase tracking-[0.2em] flex items-center gap-2">
                            <i class="bi bi-shield-exclamation"></i> Phân tích AI
                        </h4>
                        <div class="p-6 rounded-3xl bg-violet-500/[0.03] border border-violet-500/10 relative overflow-hidden">
                            <div class="absolute top-0 right-0 w-32 h-32 bg-violet-500/5 blur-3xl rounded-full -mr-16 -mt-16"></div>
                            <div class="relative prose prose-invert prose-violet max-w-none text-white/70 text-sm leading-relaxed"
                                 x-html="renderRichText(result.explanation || '')"></div>
                        </div>
                    </div>

                    <!-- Web Sources -->
                    <template x-if="result.web_sources && result.web_sources.length > 0">
                        <div class="space-y-4">
                            <h4 class="text-[10px] font-black text-white/30 uppercase tracking-[0.2em] flex items-center gap-2">
                                <i class="bi bi-globe2"></i> Nguồn tham khảo
                            </h4>
                            <div class="flex flex-wrap gap-2">
                                <template x-for="(src, idx) in result.web_sources" :key="idx">
                                    <a :href="src" target="_blank" rel="noopener" class="px-3 py-1.5 rounded-lg bg-white/5 text-white/40 text-[10px] font-bold border border-white/5 hover:bg-white/10 hover:text-white/60 transition-all truncate max-w-[280px]" x-text="src"></a>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Actions -->
            <div class="flex flex-wrap gap-4">
                <button @click="resetAll()" class="bg-white/5 hover:bg-white/10 border border-white/10 px-8 py-3.5 rounded-2xl text-white font-black text-xs uppercase tracking-widest transition-all hover:scale-[1.02]">
                    <i class="bi bi-arrow-repeat mr-2"></i> Quét khác
                </button>
                <a href="/report/" class="bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 px-8 py-3.5 rounded-2xl text-red-400 font-black text-xs uppercase tracking-widest transition-all flex items-center gap-2 hover:scale-[1.02]">
                    <i class="bi bi-exclamation-triangle"></i> Báo cáo lừa đảo
                </a>
            </div>
        </div>
    </template>
</div>
{% include 'Scan/_scan_guide.html' with scan_type='audio' %}
</div>

<style>
@keyframes spin-slow { to { transform: rotate(360deg); } }
.animate-spin-slow { animation: spin-slow 8s linear infinite; }
</style>

<script>
document.addEventListener('alpine:init', () => {
    Alpine.data('audioScanHandler', () => ({
        mode: 'upload',
        audioFile: null,
        dragging: false,
        loading: false,
        scanning: false,
        progress: [],
        result: null,
        scanId: null,
        liveTranscript: '',

        /* WebSocket state */
        ws: null,
        wsConnected: false,
        wsState: 'idle',
        reconnectAttempts: 0,
        maxReconnectAttempts: 6,
        reconnectTimer: null,
        statusPollTimer: null,

        /* Recording state */
        isRecording: false,
        mediaRecorder: null,
        audioChunks: [],
        recordedBlob: null,
        recordingDuration: 0,
        recordingTimer: null,
        audioContext: null,
        analyser: null,
        animFrameId: null,
        maxRecordingDuration: 1800,
        minRecordingDuration: 2,

        /* Mic selection */
        audioDevices: [],
        selectedDeviceId: '',
        micTesting: false,
        micLevel: 0,
        micTestStream: null,
        micTestAnalyser: null,
        micTestAnimFrame: null,

        get hasAudio() {
            return (this.mode === 'upload' && this.audioFile) || (this.mode === 'record' && this.recordedBlob);
        },

        async init() {
            await this.refreshDevices();
        },

        /* ── Device enumeration ── */
        async refreshDevices() {
            try {
                // Request permission first (needed to get labels)
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(t => t.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                this.audioDevices = devices.filter(d => d.kind === 'audioinput');

                // If selected device no longer exists, reset
                if (this.selectedDeviceId && !this.audioDevices.find(d => d.deviceId === this.selectedDeviceId)) {
                    this.selectedDeviceId = '';
                }
            } catch (err) {
                console.warn('Cannot enumerate devices:', err);
                this.audioDevices = [];
            }
        },

        async testSelectedMic() {
            this.stopMicTest();
            if (!this.selectedDeviceId && this.audioDevices.length === 0) return;

            try {
                const constraints = { audio: this.selectedDeviceId ? { deviceId: { exact: this.selectedDeviceId } } : true };
                this.micTestStream = await navigator.mediaDevices.getUserMedia(constraints);
                this.micTesting = true;

                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (ctx.state === 'suspended') await ctx.resume();
                const source = ctx.createMediaStreamSource(this.micTestStream);
                this.micTestAnalyser = ctx.createAnalyser();
                this.micTestAnalyser.fftSize = 256;
                source.connect(this.micTestAnalyser);

                const dataArray = new Uint8Array(this.micTestAnalyser.frequencyBinCount);
                const updateLevel = () => {
                    if (!this.micTesting) return;
                    this.micTestAnalyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                    this.micLevel = Math.min(100, (sum / dataArray.length) * 1.5);
                    this.micTestAnimFrame = requestAnimationFrame(updateLevel);
                };
                updateLevel();

                // Auto-stop test after 5s
                setTimeout(() => this.stopMicTest(), 5000);
            } catch (err) {
                showToast('Không thể truy cập micro đã chọn: ' + err.message, 'error');
                this.micTesting = false;
            }
        },

        stopMicTest() {
            this.micTesting = false;
            this.micLevel = 0;
            if (this.micTestAnimFrame) cancelAnimationFrame(this.micTestAnimFrame);
            if (this.micTestStream) {
                this.micTestStream.getTracks().forEach(t => t.stop());
                this.micTestStream = null;
            }
        },

        /* ── File upload handlers ── */
        handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) this.setAudioFile(file);
        },

        handleDrop(e) {
            this.dragging = false;
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                this.setAudioFile(file);
            } else {
                showToast('Vui lòng kéo thả file âm thanh.', 'warning');
            }
        },

        setAudioFile(file) {
            this.audioFile = file;
            this.result = null;
            this.$nextTick(() => {
                if (this.$refs.audioPreview) {
                    this.$refs.audioPreview.src = URL.createObjectURL(file);
                }
            });
        },

        removeFile() {
            this.audioFile = null;
            this.result = null;
            if (this.$refs.audioInput) this.$refs.audioInput.value = '';
        },

        /* ── Recording handlers ── */
        async startRecording() {
            this.stopMicTest();

            try {
                const audioConstraints = {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 44100,
                    channelCount: 1,
                };
                // Use selected mic if specified
                if (this.selectedDeviceId) {
                    audioConstraints.deviceId = { exact: this.selectedDeviceId };
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

                // Verify the stream has active audio tracks
                const audioTrack = stream.getAudioTracks()[0];
                if (!audioTrack || audioTrack.readyState !== 'live') {
                    showToast('Microphone không hoạt động. Vui lòng kiểm tra thiết bị.', 'error');
                    stream.getTracks().forEach(t => t.stop());
                    return;
                }

                this.audioChunks = [];
                this.recordingDuration = 0;
                this.recordedBlob = null;

                // Choose best available format
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/ogg;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    ''  // browser default
                ];
                let mimeType = '';
                for (const mt of mimeTypes) {
                    if (!mt || MediaRecorder.isTypeSupported(mt)) { mimeType = mt; break; }
                }

                const recorderOptions = { audioBitsPerSecond: 128000 };
                if (mimeType) recorderOptions.mimeType = mimeType;

                this.mediaRecorder = new MediaRecorder(stream, recorderOptions);

                this.mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) this.audioChunks.push(e.data);
                };

                this.mediaRecorder.onstop = () => {
                    const blobType = mimeType || 'audio/webm';
                    this.recordedBlob = new Blob(this.audioChunks, { type: blobType });
                    stream.getTracks().forEach(t => t.stop());
                    this.stopWaveform();

                    if (this.recordingDuration < this.minRecordingDuration) {
                        showToast('Ghi âm quá ngắn (tối thiểu 2 giây). Vui lòng thử lại.', 'warning');
                        this.discardRecording();
                        return;
                    }

                    // Verify non-empty blob
                    if (this.recordedBlob.size < 100) {
                        showToast('Ghi âm rỗng. Microphone có thể không hoạt động đúng.', 'error');
                        this.discardRecording();
                        return;
                    }

                    this.$nextTick(() => {
                        if (this.$refs.recordedPreview) {
                            this.$refs.recordedPreview.src = URL.createObjectURL(this.recordedBlob);
                        }
                    });
                };

                this.mediaRecorder.onerror = (e) => {
                    console.error('MediaRecorder error:', e);
                    showToast('Lỗi ghi âm: ' + (e.error?.message || 'Không xác định'), 'error');
                    this.stopRecording();
                };

                // Use smaller timeslice (100ms) for more reliable data capture
                this.mediaRecorder.start(100);
                this.isRecording = true;

                // Duration timer
                this.recordingTimer = setInterval(() => {
                    this.recordingDuration++;
                    if (this.recordingDuration >= this.maxRecordingDuration) {
                        showToast('Đã đạt thời gian tối đa (30 phút). Tự động dừng.', 'info');
                        this.stopRecording();
                    }
                }, 1000);

                // Waveform visualization
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioContext.state === 'suspended') await this.audioContext.resume();
                const source = this.audioContext.createMediaStreamSource(stream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                source.connect(this.analyser);
                this.drawWaveform();
            } catch (err) {
                if (err.name === 'NotAllowedError') {
                    showToast('Bạn đã từ chối quyền truy cập microphone. Vui lòng cấp quyền trong cài đặt trình duyệt.', 'error');
                } else if (err.name === 'NotFoundError') {
                    showToast('Không tìm thấy microphone. Vui lòng kiểm tra thiết bị.', 'error');
                } else if (err.name === 'NotReadableError' || err.name === 'AbortError') {
                    showToast('Microphone đang bận hoặc không thể đọc. Thử chọn thiết bị khác.', 'error');
                } else if (err.name === 'OverconstrainedError') {
                    // Fallback: try without specific device
                    showToast('Micro đã chọn không khả dụng. Đang thử micro mặc định...', 'warning');
                    this.selectedDeviceId = '';
                    this.$nextTick(() => this.startRecording());
                    return;
                } else {
                    showToast('Không thể truy cập microphone: ' + err.message, 'error');
                }
            }
        },

        stopRecording() {
            if (this.mediaRecorder && this.isRecording) {
                this.isRecording = false;
                clearInterval(this.recordingTimer);
                if (this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
            }
        },

        discardRecording() {
            this.recordedBlob = null;
            this.audioChunks = [];
            this.recordingDuration = 0;
        },

        drawWaveform() {
            const canvas = this.$refs.waveCanvas;
            if (!canvas || !this.analyser) return;
            const ctx = canvas.getContext('2d');
            const bufferLength = this.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const draw = () => {
                if (!this.isRecording) return;
                this.animFrameId = requestAnimationFrame(draw);
                this.analyser.getByteFrequencyData(dataArray);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const barCount = 64;
                const barWidth = canvas.width / barCount - 1;
                const step = Math.floor(bufferLength / barCount);

                for (let i = 0; i < barCount; i++) {
                    const val = dataArray[i * step] / 255;
                    const barHeight = Math.max(2, val * canvas.height * 0.9);
                    const x = i * (barWidth + 1);
                    const y = (canvas.height - barHeight) / 2;

                    const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                    gradient.addColorStop(0, `rgba(139, 92, 246, ${0.3 + val * 0.7})`);
                    gradient.addColorStop(1, `rgba(217, 70, 239, ${0.2 + val * 0.6})`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barWidth, barHeight, 2);
                    ctx.fill();
                }
            };
            draw();
        },

        stopWaveform() {
            if (this.animFrameId) cancelAnimationFrame(this.animFrameId);
            if (this.audioContext) {
                this.audioContext.close().catch(() => {});
                this.audioContext = null;
            }
        },

        /* ── Scan workflow ── */
        async startScan() {
            if (!this.hasAudio) return;

            if (this.mode === 'record' && this.recordedBlob && this.recordingDuration < this.minRecordingDuration) {
                showToast('Ghi âm quá ngắn. Vui lòng ghi âm ít nhất 2 giây.', 'warning');
                return;
            }

            const turnstileResponse = document.querySelector('[name="cf-turnstile-response"]')?.value;
            if (!turnstileResponse) {
                showToast('Vui lòng hoàn thành xác minh anti-spam.', 'warning');
                return;
            }

            this.loading = true;
            this.scanning = false;
            this.progress = [];
            this.liveTranscript = '';
            this.result = null;

            const formData = new FormData();
            if (this.mode === 'upload' && this.audioFile) {
                formData.append('audio', this.audioFile);
            } else if (this.mode === 'record' && this.recordedBlob) {
                const ext = this.recordedBlob.type.includes('ogg') ? 'ogg' : 'webm';
                formData.append('audio', this.recordedBlob, `recording.${ext}`);
            }
            formData.append('cf-turnstile-response', turnstileResponse);

            this.progress.push({ message: 'Đang tải âm thanh lên hệ thống...', step: 'uploading' });

            try {
                const resp = await fetch('/api/v1/scan/audio/', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': getCSRFToken() },
                    body: formData,
                });
                const data = await resp.json();

                if (!resp.ok || !data.scan_id) {
                    showToast(data.error || 'Lỗi khi gửi file âm thanh.', 'error');
                    this.resetScanState();
                    return;
                }

                this.scanId = data.scan_id;
                this.scanning = true;
                this.connectWebSocket(data.scan_id);
                this.startStatusPolling();
            } catch (e) {
                showToast('Lỗi kết nối máy chủ.', 'error');
                this.resetScanState();
            }
        },

        /* ── WebSocket ── */
        connectWebSocket(scanId, isReconnect = false) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/scan/${scanId}/`;
            this.scanId = scanId;
            this.wsState = isReconnect ? 'reconnecting' : 'connecting';

            if (!isReconnect) {
                this.progress.push({ message: 'Đang kết nối hệ thống phân tích...', step: 'init' });
            }

            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.wsConnected = true;
                this.wsState = 'connected';
                this.reconnectAttempts = 0;
                this.stopReconnect();
                if (isReconnect) {
                    this.progress.push({ message: 'Kết nối đã được khôi phục.', step: 'reconnected' });
                }
                this.ws.send(JSON.stringify({ type: 'get_status' }));
            };

            this.ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.step !== 'ping') {
                    this.progress.push({ message: data.message, step: data.step });
                }

                if (data.step === 'transcribed' && data.data && data.data.transcript) {
                    this.liveTranscript = data.data.transcript;
                }

                if (data.step === 'completed' && data.data) {
                    this.result = data.data;
                    this.loading = false;
                    this.scanning = false;
                    this.wsState = 'completed';
                    this.stopReconnect();
                    this.stopStatusPolling();
                    this.ws.close();
                }
                if (data.step === 'error') {
                    showToast(data.message, 'error');
                    this.resetScanState();
                    this.wsState = 'failed';
                    this.stopReconnect();
                    this.stopStatusPolling();
                    this.ws.close();
                }
            };

            this.ws.onerror = () => { this.wsConnected = false; };
            this.ws.onclose = () => {
                this.wsConnected = false;
                if (this.loading || this.scanning) {
                    this.scheduleReconnect();
                    this.startStatusPolling();
                }
            };
        },

        scheduleReconnect() {
            if (!this.scanId || (!this.loading && !this.scanning)) return;
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                this.wsState = 'disconnected';
                this.progress.push({ message: 'Mất kết nối. Đang đồng bộ trạng thái...', step: 'warning' });
                this.startStatusPolling();
                return;
            }
            this.reconnectAttempts++;
            this.wsState = 'reconnecting';
            const delay = Math.min(10000, 1000 * Math.pow(2, this.reconnectAttempts - 1));
            this.stopReconnect();
            this.reconnectTimer = setTimeout(() => this.connectWebSocket(this.scanId, true), delay);
        },

        startStatusPolling() {
            if (!this.scanId || this.statusPollTimer) return;
            this.statusPollTimer = setInterval(() => this.fetchScanStatus(), 4000);
        },

        fetchScanStatus() {
            if (!this.scanId) return;
            fetch(`/api/v1/scan/status/${this.scanId}/`, {
                method: 'GET',
                headers: { 'X-CSRFToken': getCSRFToken() },
            })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data) return;
                if (data.status === 'completed' && data.result) {
                    this.result = data.result;
                    this.loading = false;
                    this.scanning = false;
                    this.wsState = 'completed';
                    this.stopStatusPolling();
                    this.stopReconnect();
                    if (this.ws) this.ws.close();
                } else if (data.status === 'failed') {
                    this.resetScanState();
                    this.wsState = 'failed';
                    this.progress.push({ message: 'Phiên quét thất bại.', step: 'error' });
                    this.stopStatusPolling();
                    this.stopReconnect();
                }
            })
            .catch(() => {});
        },

        stopReconnect() {
            if (this.reconnectTimer) { clearTimeout(this.reconnectTimer); this.reconnectTimer = null; }
        },

        stopStatusPolling() {
            if (this.statusPollTimer) { clearInterval(this.statusPollTimer); this.statusPollTimer = null; }
        },

        /* ── Reset helpers ── */
        resetScanState() {
            this.loading = false;
            this.scanning = false;
        },

        resetAll() {
            this.audioFile = null;
            this.recordedBlob = null;
            this.audioChunks = [];
            this.recordingDuration = 0;
            this.result = null;
            this.loading = false;
            this.scanning = false;
            this.progress = [];
            this.liveTranscript = '';
            this.scanId = null;
            this.stopReconnect();
            this.stopStatusPolling();
            this.stopMicTest();
            if (this.ws) this.ws.close();
            if (this.$refs.audioInput) this.$refs.audioInput.value = '';
        },

        /* ── Formatters ── */
        formatBytes(bytes, decimals = 2) {
            if (!bytes) return '0 B';
            const k = 1024, dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        },

        formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        },

        formatTimestamp(seconds) {
            if (!seconds && seconds !== 0) return '00:00';
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        },
    }));
});

function getCSRFToken() {
    return document.cookie.split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
}
</script>
{% endblock %}
