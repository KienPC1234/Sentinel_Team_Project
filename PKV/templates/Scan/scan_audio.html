{% extends "base.html" %}
{% load static %}

{% block title %}Quét Âm Thanh - ShieldCall VN{% endblock %}

{% block content %}
<div class="max-w-7xl mx-auto px-4 lg:grid lg:grid-cols-[1fr_340px] lg:gap-8 lg:items-start">
<div class="space-y-10" x-data="audioScanHandler()">

    <!-- Page Header -->
    <div class="text-center space-y-4" data-aos="fade-up">
        <div class="inline-flex items-center justify-center w-20 h-20 rounded-[2rem] bg-violet-500/10 text-violet-400 border border-violet-500/20 shadow-lg shadow-violet-500/10 mb-2" data-aos="zoom-in" data-aos-delay="100">
            <i class="bi bi-mic text-4xl"></i>
        </div>
        <h1 class="text-4xl font-black text-white tracking-tight leading-none" data-aos="fade-up" data-aos-delay="200">
            Quét <span class="glow-text text-violet-400">Âm Thanh</span>
        </h1>
        <p class="text-white/40 max-w-md mx-auto text-sm leading-relaxed" data-aos="fade-up" data-aos-delay="300">
            Tải lên file ghi âm hoặc ghi âm trực tiếp để AI nhận diện giọng nói và phân tích nội dung lừa đảo.
        </p>
    </div>

    <!-- Upload / Record Card -->
    <div x-show="!result" class="liquid-card p-6 sm:p-10 relative group" data-aos="fade-up" data-aos-delay="400">
        <div class="absolute inset-0 bg-gradient-to-br from-violet-500/5 to-fuchsia-500/5 opacity-0 group-hover:opacity-100 transition-opacity rounded-3xl"></div>

        <div class="relative z-10">
            <!-- Tab selector -->
            <div class="flex justify-center gap-2 mb-8">
                <button @click="mode = 'upload'" class="px-6 py-2.5 rounded-xl text-xs font-black uppercase tracking-widest transition-all"
                        :class="mode === 'upload' ? 'bg-violet-500 text-white shadow-lg shadow-violet-500/25' : 'bg-white/5 text-white/40 hover:text-white'">
                    <i class="bi bi-cloud-upload mr-2"></i> Tải File
                </button>
                <button @click="mode = 'record'" class="px-6 py-2.5 rounded-xl text-xs font-black uppercase tracking-widest transition-all"
                        :class="mode === 'record' ? 'bg-violet-500 text-white shadow-lg shadow-violet-500/25' : 'bg-white/5 text-white/40 hover:text-white'">
                    <i class="bi bi-mic mr-2"></i> Ghi Âm
                </button>
            </div>

            <!-- Upload Mode -->
            <div x-show="mode === 'upload'" x-transition>
                <template x-if="!audioFile">
                    <div class="flex flex-col items-center justify-center py-14 border-2 border-dashed border-white/10 rounded-2xl hover:border-violet-500/30 transition-all cursor-pointer"
                         @click="$refs.audioInput.click()"
                         @dragover.prevent="dragging = true"
                         @dragleave.prevent="dragging = false"
                         @drop.prevent="handleDrop($event)"
                         :class="dragging ? 'bg-violet-500/10 border-violet-500/50 scale-[0.99]' : ''">
                        <input type="file" x-ref="audioInput" accept=".mp3,.m4a,.wav,.ogg,.webm,.flac,.aac,audio/*" class="hidden"
                               @change="handleFileSelect($event)">
                        <i class="bi bi-soundwave text-5xl text-white/20 mb-4 group-hover:text-violet-500/50 transition-colors"></i>
                        <p class="text-white font-bold text-lg mb-2">Click hoặc kéo thả file âm thanh</p>
                        <p class="text-white/40 text-sm">Hỗ trợ MP3, WAV, M4A, OGG, WebM, FLAC, AAC (Tối đa 50MB)</p>
                    </div>
                </template>

                <template x-if="audioFile">
                    <div class="space-y-4">
                        <div class="bg-black/20 rounded-2xl p-6 border border-white/10 flex items-center gap-4">
                            <div class="w-14 h-14 rounded-xl bg-violet-500/10 flex items-center justify-center text-violet-400 text-2xl">
                                <i class="bi bi-file-earmark-music"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <h4 class="text-white font-bold truncate" x-text="audioFile.name"></h4>
                                <p class="text-white/40 text-xs" x-text="formatBytes(audioFile.size)"></p>
                            </div>
                            <button @click="removeFile()" x-show="!loading" class="text-white/30 hover:text-white transition-colors">
                                <i class="bi bi-x-circle text-xl"></i>
                            </button>
                        </div>
                        <!-- Audio preview -->
                        <audio x-ref="audioPreview" controls class="w-full rounded-xl opacity-60 hover:opacity-100 transition-opacity"></audio>
                    </div>
                </template>
            </div>

            <!-- Record Mode -->
            <div x-show="mode === 'record'" x-transition class="flex flex-col items-center">
                <!-- Recording visualization -->
                <div class="mb-8 flex flex-col items-center">
                    <div class="relative w-32 h-32 flex items-center justify-center mb-4">
                        <!-- Pulse ring when recording -->
                        <div x-show="isRecording" class="absolute inset-0 rounded-full bg-red-500/20 animate-ping"></div>
                        <div x-show="isRecording" class="absolute inset-2 rounded-full bg-red-500/10 animate-pulse"></div>

                        <button @click="isRecording ? stopRecording() : startRecording()"
                                class="relative w-24 h-24 rounded-full flex items-center justify-center text-3xl transition-all duration-300 z-10"
                                :class="isRecording ? 'bg-red-500 text-white shadow-xl shadow-red-500/40 scale-110' : 'bg-white/5 text-white/40 border-2 border-white/10 hover:border-violet-500/50 hover:text-violet-400'">
                            <i :class="isRecording ? 'bi bi-stop-fill' : 'bi bi-mic-fill'"></i>
                        </button>
                    </div>

                    <p class="text-white/60 text-sm font-bold" x-show="!isRecording && !recordedBlob" >Nhấn để bắt đầu ghi âm</p>
                    <p class="text-red-400 text-sm font-bold animate-pulse" x-show="isRecording">
                        <i class="bi bi-record-circle mr-1"></i> Đang ghi âm — <span x-text="formatTime(recordingDuration)"></span>
                    </p>

                    <!-- Waveform visualization -->
                    <canvas x-ref="waveCanvas" x-show="isRecording" width="300" height="60" class="mt-4 rounded-xl opacity-80"></canvas>
                </div>

                <!-- Recorded file preview -->
                <template x-if="recordedBlob && !isRecording">
                    <div class="w-full space-y-4">
                        <div class="bg-black/20 rounded-2xl p-6 border border-white/10 flex items-center gap-4">
                            <div class="w-14 h-14 rounded-xl bg-violet-500/10 flex items-center justify-center text-violet-400 text-2xl">
                                <i class="bi bi-mic-fill"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <h4 class="text-white font-bold">Bản ghi âm</h4>
                                <p class="text-white/40 text-xs" x-text="formatTime(recordingDuration) + ' • ' + formatBytes(recordedBlob.size)"></p>
                            </div>
                            <button @click="discardRecording()" x-show="!loading" class="text-white/30 hover:text-white transition-colors">
                                <i class="bi bi-x-circle text-xl"></i>
                            </button>
                        </div>
                        <audio x-ref="recordedPreview" controls class="w-full rounded-xl opacity-60 hover:opacity-100 transition-opacity"></audio>
                    </div>
                </template>
            </div>

            <!-- Action buttons -->
            <div class="mt-8 flex flex-col items-center gap-6" x-show="hasAudio && !loading && !scanning">
                <div class="cf-turnstile" data-sitekey="{{ TURNSTILE_SITEKEY }}" :data-theme="document.documentElement.getAttribute('data-theme') || 'dark'" data-size="flexible"></div>
                <button @click="startScan()" class="liquid-button bg-violet-500 hover:bg-violet-400 text-white px-12 py-4 rounded-2xl font-black uppercase tracking-widest shadow-xl shadow-violet-500/25 flex items-center gap-3">
                    <i class="bi bi-shield-shaded"></i> Phân tích âm thanh
                </button>
            </div>
        </div>
    </div>

    <!-- Progress Console -->
    <template x-if="(loading || scanning) && progress.length > 0">
        <div class="liquid-card p-6 border-violet-500/20 bg-violet-500/[0.02] animate-fadein">
            <div class="mb-4 flex items-center justify-between gap-3">
                <h4 class="text-[10px] font-black text-violet-400 uppercase tracking-widest">Nhật ký phân tích thời gian thực</h4>
                <div class="flex items-center gap-3">
                    <span class="text-[10px] text-white/30 font-mono" x-text="progress.length + ' bước'"></span>
                    <div class="text-[10px] font-black uppercase tracking-wider px-2 py-1 rounded border"
                         :class="wsState==='connected' ? 'text-green-400 border-green-500/30 bg-green-500/10' : (wsState==='reconnecting' || wsState==='connecting') ? 'text-yellow-400 border-yellow-500/30 bg-yellow-500/10' : 'text-red-400 border-red-500/30 bg-red-500/10'"
                         x-text="wsState==='connected' ? 'WS Connected' : (wsState==='reconnecting' ? 'Reconnecting' : (wsState==='connecting' ? 'Connecting' : 'Disconnected'))"></div>
                </div>
            </div>
            <div class="w-full h-1 bg-white/5 rounded-full overflow-hidden mb-4">
                <div class="h-full bg-violet-500/50 transition-all duration-500 rounded-full"
                     :style="'width:' + Math.min(95, progress.length * 20) + '%'"></div>
            </div>
            <div class="space-y-3 font-mono text-[11px] max-h-[300px] overflow-y-auto custom-scrollbar">
                <template x-for="(item, index) in progress" :key="index">
                    <div class="flex items-start gap-3 animate-fadein">
                        <span class="flex-shrink-0 mt-0.5"
                              :class="item.step === 'completed' ? 'text-green-500' :
                                      item.step === 'error' ? 'text-red-500' :
                                      item.step === 'transcribing' ? 'text-blue-400' :
                                      item.step === 'transcribed' ? 'text-emerald-400' :
                                      item.step === 'analyzing' || item.step === 'analyzed' ? 'text-orange-400' :
                                      'text-violet-500/50'">
                            <i :class="item.step === 'completed' ? 'bi bi-check-circle-fill' :
                                       item.step === 'error' ? 'bi bi-x-circle-fill' :
                                       item.step === 'transcribing' ? 'bi bi-soundwave' :
                                       item.step === 'transcribed' ? 'bi bi-chat-left-text-fill' :
                                       item.step === 'analyzing' || item.step === 'analyzed' ? 'bi bi-cpu-fill' :
                                       (index === progress.length - 1 ? 'bi bi-arrow-right' : 'bi bi-dot')"></i>
                        </span>
                        <span class="text-white/80 flex-1" x-text="item.message"></span>
                        <i x-show="index === progress.length - 1 && item.step !== 'completed'" class="bi bi-three-dots animate-pulse text-violet-400 flex-shrink-0"></i>
                        <i x-show="item.step === 'completed' || index < progress.length - 1" class="bi bi-check2 text-violet-400 flex-shrink-0"></i>
                    </div>
                </template>
            </div>

            <!-- Live transcript preview -->
            <template x-if="liveTranscript">
                <div class="mt-4 p-4 rounded-2xl bg-white/[0.02] border border-white/5">
                    <div class="text-[9px] font-black text-white/20 uppercase tracking-widest mb-2">Bản ghi nhận dạng</div>
                    <p class="text-white/60 text-sm leading-relaxed italic" x-text="liveTranscript"></p>
                </div>
            </template>
        </div>
    </template>

    <!-- Result Display -->
    <template x-if="result">
        <div class="space-y-8 animate-fadein">
            <div class="liquid-card overflow-hidden">
                <!-- Status Header -->
                <div class="p-8 text-center border-b border-white/5 bg-white/[0.02] relative overflow-hidden">
                    <div class="absolute inset-0 opacity-10 -z-10 blur-[80px]"
                         :class="result.risk_level==='RED' ? 'bg-red-500' : result.risk_level==='YELLOW' ? 'bg-yellow-500' : 'bg-green-500'"></div>

                    <div class="inline-block px-8 py-3 rounded-full text-xs font-black tracking-[0.3em] uppercase mb-6"
                         :class="result.risk_level==='RED' ? 'bg-red-500/20 text-red-500 border border-red-500/30' : result.risk_level==='YELLOW' ? 'bg-yellow-500/20 text-yellow-500 border border-yellow-500/30' : 'bg-green-500/20 text-green-500 border border-green-500/30'"
                         x-text="result.risk_level === 'RED' ? 'NGUY HIỂM' : result.risk_level === 'YELLOW' ? 'NGHI VẤN' : 'AN TOÀN'"></div>

                    <div class="relative inline-block mb-4">
                        <svg class="w-36 h-36 transform -rotate-90">
                            <circle cx="72" cy="72" r="64" stroke="currentColor" stroke-width="8" fill="transparent" class="text-white/5" />
                            <circle cx="72" cy="72" r="64" stroke="currentColor" stroke-width="8" fill="transparent"
                                    :stroke-dasharray="402" :stroke-dashoffset="402 * (1 - (result.risk_score || 0)/100)"
                                    :class="result.risk_level==='RED' ? 'text-red-500' : result.risk_level==='YELLOW' ? 'text-yellow-400' : 'text-green-400'"
                                    class="transition-all duration-1000 ease-out" />
                        </svg>
                        <div class="absolute inset-0 flex flex-col items-center justify-center">
                            <span class="text-4xl font-black text-white" x-text="result.risk_score || 0"></span>
                            <span class="text-[8px] uppercase font-black text-white/30">Rủi ro</span>
                        </div>
                    </div>

                    <!-- Audio meta info -->
                    <div class="flex justify-center gap-6 text-xs text-white/40">
                        <span x-show="result.language"><i class="bi bi-translate mr-1"></i> <span x-text="result.language"></span></span>
                        <span x-show="result.duration"><i class="bi bi-clock mr-1"></i> <span x-text="result.duration ? result.duration.toFixed(1) + 's' : ''"></span></span>
                        <span x-show="result.segments"><i class="bi bi-list-ol mr-1"></i> <span x-text="(result.segments?.length || 0) + ' đoạn'"></span></span>
                    </div>
                </div>

                <div class="p-8 space-y-10">
                    <!-- Transcript -->
                    <div class="space-y-4">
                        <h4 class="text-xs font-black text-violet-400 uppercase tracking-widest flex items-center gap-2">
                            <i class="bi bi-chat-left-text"></i> Nội dung nhận diện
                        </h4>
                        <template x-if="result.segments && result.segments.length > 0">
                            <div class="space-y-2 max-h-[400px] overflow-y-auto custom-scrollbar">
                                <template x-for="(seg, idx) in result.segments" :key="idx">
                                    <div class="flex gap-3 p-3 rounded-xl bg-white/[0.02] border border-white/5 hover:bg-white/[0.04] transition-colors">
                                        <span class="text-[10px] font-mono text-white/20 whitespace-nowrap pt-0.5"
                                              x-text="formatTimestamp(seg.start) + ' →'"></span>
                                        <span class="text-white/70 text-sm leading-relaxed" x-text="seg.text"></span>
                                    </div>
                                </template>
                            </div>
                        </template>
                        <template x-if="!result.segments || result.segments.length === 0">
                            <div class="p-4 rounded-2xl bg-white/[0.02] border border-white/5">
                                <p class="text-white/60 text-sm leading-relaxed" x-text="result.transcript || 'Không nhận diện được nội dung.'"></p>
                            </div>
                        </template>
                    </div>

                    <!-- Full transcript (copyable) -->
                    <template x-if="result.transcript">
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="text-xs font-black text-white/40 uppercase tracking-widest flex items-center gap-2">
                                    <i class="bi bi-file-text"></i> Văn bản đầy đủ
                                </h4>
                                <button @click="navigator.clipboard.writeText(result.transcript); showToast('Đã sao chép!','success')"
                                        class="liquid-btn p-2 px-3 bg-white/5 text-white/40 hover:text-violet-400 border-white/5 text-[10px] font-bold">
                                    <i class="bi bi-copy mr-1"></i> Sao chép
                                </button>
                            </div>
                            <div class="p-5 rounded-2xl bg-black/20 border border-white/5 max-h-[200px] overflow-y-auto custom-scrollbar">
                                <p class="text-white/50 text-sm leading-relaxed font-mono whitespace-pre-wrap" x-text="result.transcript"></p>
                            </div>
                        </div>
                    </template>

                    <!-- AI Reasoning -->
                    <div class="space-y-4">
                        <h4 class="text-xs font-black text-violet-400 uppercase tracking-widest flex items-center gap-2">
                            <i class="bi bi-robot"></i> Nhận định của trí tuệ nhân tạo
                        </h4>
                        <div class="p-6 rounded-[2.5rem] bg-violet-500/[0.03] border border-violet-500/10 shadow-inner">
                            <div class="prose prose-invert prose-violet max-w-none text-white/70 text-sm leading-relaxed"
                                 x-html="renderRichText(result.explanation || '')"></div>
                        </div>
                    </div>

                    <!-- Web sources -->
                    <template x-if="result.web_sources && result.web_sources.length > 0">
                        <div class="space-y-4">
                            <h4 class="text-xs font-black text-white/40 uppercase tracking-widest flex items-center gap-2">
                                <i class="bi bi-globe2"></i> Nguồn tham khảo
                            </h4>
                            <div class="flex flex-wrap gap-2">
                                <template x-for="(src, idx) in result.web_sources" :key="idx">
                                    <a :href="src" target="_blank" rel="noopener" class="px-3 py-1 rounded bg-white/5 text-white/40 text-[10px] font-bold border border-white/10 hover:bg-white/10 transition-all truncate max-w-[250px]" x-text="src"></a>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Actions -->
            <div class="flex flex-wrap gap-4">
                <button @click="resetAll()" class="bg-white/5 hover:bg-white/10 border border-white/10 px-8 py-3 rounded-xl text-white font-bold transition-all">
                    <i class="bi bi-arrow-repeat mr-2"></i> Quét khác
                </button>
                <a href="/report/" class="bg-red-500/20 hover:bg-red-500/30 border border-red-500/30 px-8 py-3 rounded-xl text-red-500 font-bold transition-all flex items-center gap-2">
                    <i class="bi bi-exclamation-triangle"></i> Báo cáo lừa đảo
                </a>
            </div>
        </div>
    </template>
</div>
{% include 'Scan/_scan_guide.html' with scan_type='audio' %}
</div>

<script>
function audioScanHandler() {
    return {
        mode: 'upload',
        audioFile: null,
        dragging: false,
        loading: false,
        scanning: false,
        progress: [],
        result: null,
        scanId: null,
        liveTranscript: '',

        /* WebSocket state */
        ws: null,
        wsConnected: false,
        wsState: 'idle',
        reconnectAttempts: 0,
        maxReconnectAttempts: 6,
        reconnectTimer: null,
        statusPollTimer: null,

        /* Recording state */
        isRecording: false,
        mediaRecorder: null,
        audioChunks: [],
        recordedBlob: null,
        recordingDuration: 0,
        recordingTimer: null,
        audioContext: null,
        analyser: null,
        animFrameId: null,

        get hasAudio() {
            return (this.mode === 'upload' && this.audioFile) || (this.mode === 'record' && this.recordedBlob);
        },

        /* ── File upload handlers ── */
        handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) this.setAudioFile(file);
        },

        handleDrop(e) {
            this.dragging = false;
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                this.setAudioFile(file);
            } else {
                showToast('Vui lòng kéo thả file âm thanh.', 'warning');
            }
        },

        setAudioFile(file) {
            this.audioFile = file;
            this.result = null;
            this.$nextTick(() => {
                if (this.$refs.audioPreview) {
                    this.$refs.audioPreview.src = URL.createObjectURL(file);
                }
            });
        },

        removeFile() {
            this.audioFile = null;
            this.result = null;
            if (this.$refs.audioInput) this.$refs.audioInput.value = '';
        },

        /* ── Recording handlers ── */
        async startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.audioChunks = [];
                this.recordingDuration = 0;
                this.recordedBlob = null;

                // Set up MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
                this.mediaRecorder = new MediaRecorder(stream, { mimeType });
                this.mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) this.audioChunks.push(e.data);
                };
                this.mediaRecorder.onstop = () => {
                    this.recordedBlob = new Blob(this.audioChunks, { type: mimeType });
                    stream.getTracks().forEach(t => t.stop());
                    this.stopWaveform();
                    this.$nextTick(() => {
                        if (this.$refs.recordedPreview) {
                            this.$refs.recordedPreview.src = URL.createObjectURL(this.recordedBlob);
                        }
                    });
                };
                this.mediaRecorder.start(250);
                this.isRecording = true;

                // Duration timer
                this.recordingTimer = setInterval(() => { this.recordingDuration++; }, 1000);

                // Waveform visualization
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(stream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                source.connect(this.analyser);
                this.drawWaveform();
            } catch (err) {
                showToast('Không thể truy cập microphone. Vui lòng cấp quyền.', 'error');
            }
        },

        stopRecording() {
            if (this.mediaRecorder && this.isRecording) {
                this.mediaRecorder.stop();
                this.isRecording = false;
                clearInterval(this.recordingTimer);
            }
        },

        discardRecording() {
            this.recordedBlob = null;
            this.audioChunks = [];
            this.recordingDuration = 0;
        },

        drawWaveform() {
            const canvas = this.$refs.waveCanvas;
            if (!canvas || !this.analyser) return;
            const ctx = canvas.getContext('2d');
            const bufferLength = this.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const draw = () => {
                if (!this.isRecording) return;
                this.animFrameId = requestAnimationFrame(draw);
                this.analyser.getByteFrequencyData(dataArray);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    const hue = 270 + (i / bufferLength) * 30;
                    ctx.fillStyle = `hsla(${hue}, 80%, 65%, 0.8)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            };
            draw();
        },

        stopWaveform() {
            if (this.animFrameId) cancelAnimationFrame(this.animFrameId);
            if (this.audioContext) {
                this.audioContext.close().catch(() => {});
                this.audioContext = null;
            }
        },

        /* ── Scan workflow ── */
        async startScan() {
            if (!this.hasAudio) return;

            const turnstileResponse = document.querySelector('[name="cf-turnstile-response"]')?.value;
            if (!turnstileResponse) {
                showToast('Vui lòng hoàn thành xác minh anti-spam.', 'warning');
                return;
            }

            this.loading = true;
            this.scanning = false;
            this.progress = [];
            this.liveTranscript = '';
            this.result = null;

            const formData = new FormData();
            if (this.mode === 'upload' && this.audioFile) {
                formData.append('audio', this.audioFile);
            } else if (this.mode === 'record' && this.recordedBlob) {
                formData.append('audio', this.recordedBlob, 'recording.webm');
            }
            formData.append('cf-turnstile-response', turnstileResponse);

            this.progress.push({ message: 'Đang tải âm thanh lên hệ thống...', step: 'uploading' });

            try {
                const resp = await fetch('/api/v1/scan/audio/', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': getCSRFToken() },
                    body: formData,
                });
                const data = await resp.json();

                if (!resp.ok || !data.scan_id) {
                    showToast(data.error || 'Lỗi khi gửi file âm thanh.', 'error');
                    this.resetScanState();
                    return;
                }

                this.scanId = data.scan_id;
                this.scanning = true;
                this.connectWebSocket(data.scan_id);
                this.startStatusPolling();
            } catch (e) {
                showToast('Lỗi kết nối máy chủ.', 'error');
                this.resetScanState();
            }
        },

        /* ── WebSocket ── */
        connectWebSocket(scanId, isReconnect = false) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/scan/${scanId}/`;
            this.scanId = scanId;
            this.wsState = isReconnect ? 'reconnecting' : 'connecting';

            if (!isReconnect) {
                this.progress.push({ message: 'Đang kết nối hệ thống phân tích...', step: 'init' });
            }

            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.wsConnected = true;
                this.wsState = 'connected';
                this.reconnectAttempts = 0;
                this.stopReconnect();
                if (isReconnect) {
                    this.progress.push({ message: 'Kết nối thời gian thực đã được khôi phục.', step: 'reconnected' });
                }
                // Ask server for current status to catch results missed during disconnection
                this.ws.send(JSON.stringify({ type: 'get_status' }));
            };

            this.ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.step !== 'ping') {
                    this.progress.push({ message: data.message, step: data.step });
                }

                // Capture live transcript from the transcribed step
                if (data.step === 'transcribed' && data.data && data.data.transcript) {
                    this.liveTranscript = data.data.transcript;
                }

                if (data.step === 'completed' && data.data) {
                    this.result = data.data;
                    this.loading = false;
                    this.scanning = false;
                    this.wsState = 'completed';
                    this.stopReconnect();
                    this.stopStatusPolling();
                    this.ws.close();
                }
                if (data.step === 'error') {
                    showToast(data.message, 'error');
                    this.resetScanState();
                    this.wsState = 'failed';
                    this.stopReconnect();
                    this.stopStatusPolling();
                    this.ws.close();
                }
            };

            this.ws.onerror = () => { this.wsConnected = false; };
            this.ws.onclose = () => {
                this.wsConnected = false;
                if (this.loading || this.scanning) {
                    this.scheduleReconnect();
                    this.startStatusPolling();
                }
            };
        },

        scheduleReconnect() {
            if (!this.scanId || (!this.loading && !this.scanning)) return;
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                this.wsState = 'disconnected';
                this.progress.push({ message: 'Mất kết nối. Đang chuyển sang đồng bộ trạng thái.', step: 'warning' });
                this.startStatusPolling();
                return;
            }
            this.reconnectAttempts++;
            this.wsState = 'reconnecting';
            const delay = Math.min(10000, 1000 * Math.pow(2, this.reconnectAttempts - 1));
            this.stopReconnect();
            this.reconnectTimer = setTimeout(() => this.connectWebSocket(this.scanId, true), delay);
        },

        startStatusPolling() {
            if (!this.scanId || this.statusPollTimer) return;
            this.statusPollTimer = setInterval(() => this.fetchScanStatus(), 4000);
        },

        fetchScanStatus() {
            if (!this.scanId) return;
            fetch(`/api/v1/scan/status/${this.scanId}/`, {
                method: 'GET',
                headers: { 'X-CSRFToken': getCSRFToken() },
            })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data) return;
                if (data.status === 'completed' && data.result) {
                    this.result = data.result;
                    this.loading = false;
                    this.scanning = false;
                    this.wsState = 'completed';
                    this.stopStatusPolling();
                    this.stopReconnect();
                    if (this.ws) this.ws.close();
                } else if (data.status === 'failed') {
                    this.resetScanState();
                    this.wsState = 'failed';
                    this.progress.push({ message: 'Phiên quét thất bại.', step: 'error' });
                    this.stopStatusPolling();
                    this.stopReconnect();
                }
            })
            .catch(() => {});
        },

        stopReconnect() {
            if (this.reconnectTimer) { clearTimeout(this.reconnectTimer); this.reconnectTimer = null; }
        },

        stopStatusPolling() {
            if (this.statusPollTimer) { clearInterval(this.statusPollTimer); this.statusPollTimer = null; }
        },

        /* ── Reset helpers ── */
        resetScanState() {
            this.loading = false;
            this.scanning = false;
        },

        resetAll() {
            this.audioFile = null;
            this.recordedBlob = null;
            this.audioChunks = [];
            this.recordingDuration = 0;
            this.result = null;
            this.loading = false;
            this.scanning = false;
            this.progress = [];
            this.liveTranscript = '';
            this.scanId = null;
            this.stopReconnect();
            this.stopStatusPolling();
            if (this.ws) this.ws.close();
            if (this.$refs.audioInput) this.$refs.audioInput.value = '';
        },

        /* ── Formatters ── */
        formatBytes(bytes, decimals = 2) {
            if (!bytes) return '0 B';
            const k = 1024, dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        },

        formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        },

        formatTimestamp(seconds) {
            if (!seconds && seconds !== 0) return '00:00';
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        },
    };
}

function getCSRFToken() {
    return document.cookie.split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
}
</script>
{% endblock %}
